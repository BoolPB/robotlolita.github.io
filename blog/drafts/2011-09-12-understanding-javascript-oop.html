---
layout: post
title:  Understanding JavaScript OOP
snip:   Prototypical inheritance on awesomeness!
---

<p>
JavaScript is an object oriented language, with its roots in the <a href="http://selflanguage.org/">Self</a>
programming language, however (sadly) designed to look like Java. This
makes the language's really powerful and sweet features stay covered by
some pretty ugly and counter-intuitive <i>work-arounds</i>.
</p>
<p>
One of such affected features is the implementation of prototypical
inheritance. The concepts are simple yet flexible and powerful. It makes
inheritance and behaviourism first-class citizens, just like functions
are first-class in functional-ish languages (JavaScript included).
</p>
<p>
Fortunately, <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript 5</a> has gotten plenty of things to move the
language in the right way, and it's on those sweetness that this article
will expand on. Though I'll also cover the drawbacks of JavaScript's
design, and do a little comparison with the classical model here and
there, where those would highlight the advantages or disadvantages of
the language's implementation of prototypical OO.
</p>
<p>
It's important to note, though, that this article assumes you have
knowledge over other basic JavaScript functionality, like functions
(including the concepts of closures and first-class functions),
primitive values and such.
</p>



<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1. Objects </h2>
<div class="outline-text-2" id="text-1">


<p>
Everything you can manipulate in JavaScript is an object. This includes
<code>Strings</code>, <code>Arrays</code>, <code>Numbers</code>, <code>Functions</code>, and, obviously, the
so-called <code>Object</code>. An object in the language is simply a collection of
key/value pairs (and a few internal magic sometimes).
</p>
<p>
There are no concepts of classes anywhere, though. That is, an object
with properties <code>name = Linda</code> is not an instance of the <code>Object</code>
class. They are entirely separate <b>instances</b> that <i>fully</i> define
their own behaviour. That is, objects are instances of themselves in
JavaScript, there are no layers of meta-data (i.e.: classes) to provide
how an object of a certain type must look like.
</p>
<p>
You might ask: "how?". More so if you come from a highly classical
Object Orientation background (like Java or C#). Wouldn't having each
object define their own behaviour, instead of a common <i>class</i> mean that
if I have 100 objects, I will have 100 different methods? Also, isn't it
dangerous? How would one know if an object is really an Array, for
example?
</p>
<p>
Well, to answer all those questions, we'll first need to unlearn
everything about the classical OO approach and start from the ground
up. But, trust me, it's worth it. The prototypical OO model brings in
some new ways of solving old problems, in an easier and more dynamic
way. It also presents new and more powerful models for extensibility and
code-reuse, which is what most people are interested about when they
talk about Object Orientation.
</p>


</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1">1.1. What are objects? </h3>
<div class="outline-text-3" id="text-1_1">


<p>
As mentioned previously, objects are simple pairs of unique keys that
correspond to a value — we'll call this pair a <code>property</code>. So, suppose
you'd want to describe a few aspects of an old friend — let's call it
<code>Mikhail</code>, like age, name and gender:
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-obj-mikhail.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-obj-mikhail.png" />
</p>
<p>
Objects are created in JavaScript using the <code>Object.create</code> function. It
takes a parent and an optional list of property descriptors and makes a
brand new instance. Though, we'll not worry much about the parameters
now.
</p>
<p>
An empty object is an object with no parent, and no properties. The
syntax to create such object in JavaScript is the following:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = Object.create(<span style="color: #FA2573;">null</span>)
</pre>




</div>

</div>

<div id="outline-container-1_2" class="outline-3">
<h3 id="sec-1_2">1.2. Creating properties </h3>
<div class="outline-text-3" id="text-1_2">


<p>
So, now we have an object, but no properties — we've got to fix that if
we want to describe <code>Mikhail</code>.
</p>
<p>
Properties in JavaScript are dynamic. That means that they can be
created or removed at any time. Properties are also unique, in the sense
that a property name inside an object correspond to exactly one value.
</p>
<p>
Creating new properties is done through the <code>Object.defineProperty</code>
function, which takes a reference to an object, the name of the property
to create and a descriptor that defines the semantics of the property.
</p>



<pre class="src src-js">Object.defineProperty(mikhail, <span style="color: #A6E32D;">'name'</span>, { value:        <span style="color: #A6E32D;">'Mikhail'</span>
                                       , writable:     <span style="color: #FA2573;">true</span>
                                       , configurable: <span style="color: #FA2573;">true</span>
                                       , enumerable:   <span style="color: #FA2573;">true</span> })

Object.defineProperty(mikhail, <span style="color: #A6E32D;">'age'</span>, { value:        19
                                      , writable:     <span style="color: #FA2573;">true</span>
                                      , configurable: <span style="color: #FA2573;">true</span>
                                      , enumerable:   <span style="color: #FA2573;">true</span> })

Object.defineProperty(mikhail, <span style="color: #A6E32D;">'gender'</span>, { value:        <span style="color: #A6E32D;">'Male'</span>
                                         , writable:     <span style="color: #FA2573;">true</span>
                                         , configurable: <span style="color: #FA2573;">true</span>
                                         , enumerable:   <span style="color: #FA2573;">true</span> })
</pre>



<p>
<code>Object.defineProperty</code> will create a new property if a property with
the given name does not exist in the object, otherwise it'll update the
semantics and value of the existing property.
</p>

</div>

</div>

<div id="outline-container-1_3" class="outline-3">
<h3 id="sec-1_3">1.3. Descriptors </h3>
<div class="outline-text-3" id="text-1_3">


<p>
Descriptors are the little object that carry the semantics of a property
(we used them in the previous <code>Object.defineProperty</code> calls).
</p>
<p>
A descriptor may be a data descriptor — it holds a concrete value — or
an accessor descriptor — it proxies the access to the concrete value
through getters and setter functions.
</p>
<p>
All the descriptors share the following attributes. Whenever these are
not given, they default to <code>false</code>.
</p>
<dl>
<dt>writable</dt><dd>

<p>
Whether the concrete value of the property may be changed.
</p>
</dd>
<dt>configurable</dt><dd>

<p>
Whether the type of descriptor may be changed, or if the property can
be removed.
</p>
</dd>
<dt>enumerable</dt><dd>

<p>
Whether the property is listed in a loop through the properties of the
object.
</p></dd>
</dl>


<p>
Data descriptors can have the following attribute. Defaults to
<code>undefined</code> when not given.
</p>
<dl>
<dt>value</dt><dd>

<p>
The value of a property.
</p></dd>
</dl>


<p>
Accessor descriptors can have the following attributes. Defaults to
<code>undefined</code> when not given.
</p>
<dl>
<dt>get ()</dt><dd>

<p>
A function called with no arguments when the property value is
requested.
</p>
</dd>
<dt>set (new_value)</dt><dd>

<p>
A function called with the new value for the property when the user
tries to modify the value of the property.
</p>
</dd>
</dl>

</div>

</div>

<div id="outline-container-1_4" class="outline-3">
<h3 id="sec-1_4">1.4. Ditching the verbosity </h3>
<div class="outline-text-3" id="text-1_4">


<p>
Luckily, property descriptors are not the only way of working with
properties in JavaScript, they can also be handled in a sane and concise
way.
</p>
<p>
JavaScript also understands references to a property using what we call
<i>bracket notation</i>. The general rule is:
</p>



<pre class="src src-bnf"><span style="color: #67D9F0;">&lt;bracket-access&gt;</span> <span style="color: #FA2573;">::=</span> <span style="color: #729FCF;">&lt;identifier&gt;</span> <span style="color: #A6E32D;">"["</span> <span style="color: #729FCF;">&lt;expression&gt;</span> <span style="color: #A6E32D;">"]"</span>
</pre>



<p>
Where <code>identifier</code> is the variable that holds the object containing the
properties we want to access, and <code>expression</code> is any valid JavaScript
expression that defines the name of the property. There are no
constraints in which name a property can have<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>, everything is fair
game.
</p>
<p>
Thus, we could just as well rewrite our previous example as:
</p>



<pre class="src src-js">mikhail[<span style="color: #A6E32D;">'name'</span>]   = <span style="color: #A6E32D;">'Mikhail'</span>
mikhail[<span style="color: #A6E32D;">'age'</span>]    = 19
mikhail[<span style="color: #A6E32D;">'gender'</span>] = <span style="color: #A6E32D;">'Male'</span>
</pre>



<p>
⁣
</p>
<dl>
<dt>Note</dt><dd>


<p>
All property names are ultimately converted to a String, such that
<code>object[1]</code>, <code>object[⁣[1]⁣]</code>, <code>object['1']</code> and <code>object[variable]</code> (when
the variable resolves to <code>1</code>) are all equivalent.
</p></dd>
</dl>


<p>
There is another way of referring to a property called <i>dot notation</i>, which usually looks better (and presents less syntactical
noises) than the bracket alternative, however it only works when the
property name is a <a href="http://es5.github.com/#x7.6">valid JavaScript identifier</a>, and don't allow
for arbitrary expressions (so, variables here are a no-go).
</p>
<p>
The rule for <i>dot notation</i> is:
</p>



<pre class="src src-bnf"><span style="color: #67D9F0;">&lt;dot-access&gt;</span> <span style="color: #FA2573;">::=</span> <span style="color: #729FCF;">&lt;identifier&gt;</span> <span style="color: #A6E32D;">"."</span> <span style="color: #729FCF;">&lt;identifier&gt;</span>
</pre>



<p>
This would give us an even sweeter way of defining properties:
</p>



<pre class="src src-js">mikhail.name   = <span style="color: #A6E32D;">'Mikhail'</span>
mikhail.age    = 19
mikhail.gender = <span style="color: #A6E32D;">'Male'</span>
</pre>



<p>
Both of these syntaxes are equivalent to creating a data property, with
all semantic flags set to <code>true</code>.
</p>

</div>

</div>

<div id="outline-container-1_5" class="outline-3">
<h3 id="sec-1_5">1.5. Accessing properties </h3>
<div class="outline-text-3" id="text-1_5">


<p>
Retrieving the values stored in a given property is as easy as creating
new ones, and the syntax is mostly similar as well — the only difference
being there isn't an assignment.
</p>
<p>
So, if we want to check on Mikhail's age:
</p>



<pre class="src src-js">mikhail[<span style="color: #A6E32D;">'age'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 19
</span></pre>



<p>
Trying to access a property that does not exist in the object simply
returns <code>undefined</code>:
</p>



<pre class="src src-js">mikhail[<span style="color: #A6E32D;">'address'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; undefined
</span></pre>




</div>

</div>

<div id="outline-container-1_6" class="outline-3">
<h3 id="sec-1_6">1.6. Removing properties </h3>
<div class="outline-text-3" id="text-1_6">


<p>
To remove entire properties from an object, JavaScript provides the
<code>delete</code> operator. So, if you wanted to remove the <code>gender</code> property
from the <code>mikhail</code> object:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">delete</span> mikhail[<span style="color: #A6E32D;">'gender'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; true
</span>
mikhail[<span style="color: #A6E32D;">'gender'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; undefined
</span></pre>



<p>
The <code>delete</code> operator returns <code>true</code> if the property was removed,
<code>false</code> otherwise. I won't delve into details of the workings of this
operator, since <a href="http://twitter.com/kangax">@kangax</a> has already written a
<a href="http://perfectionkills.com/understanding-delete/">most awesome article on how delete works</a>.
</p>

</div>

</div>

<div id="outline-container-1_7" class="outline-3">
<h3 id="sec-1_7">1.7. Getters and setters </h3>
<div class="outline-text-3" id="text-1_7">


<p>
Getters and setters are usually used in classical object oriented
languages to provide encapsulation. They are not much needed (or wanted)
in JavaScript, though, given how dynamic the language is — <del>and my bias against the feature</del>.
</p>
<p>
At any rate, they allow you to proxy the requests for reading a property
value or setting it, and decide how to handle each situation. So,
suppose we had separate slots for our object's first and last name, but
wanted a simple interface for reading and setting it.
</p>
<p>
First, let's set the first and last names of our friend, as concrete
data properties:
</p>



<pre class="src src-js">Object.defineProperty(mikhail, <span style="color: #A6E32D;">'first_name'</span>, { value:    <span style="color: #A6E32D;">'Mikhail'</span>
                                             , writable: <span style="color: #FA2573;">true</span> })

Object.defineProperty(mikhail, <span style="color: #A6E32D;">'last_name'</span>, { value:    <span style="color: #A6E32D;">'Wei&#223;'</span>
                                            , writable: <span style="color: #FA2573;">true</span> })
</pre>



<p>
Then we can define a common way of accessing and setting both of those
values at the same time — let's call it <code>name</code>:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">() &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Returns the full name of object.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">get_full_name</span>() {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.first_name + <span style="color: #A6E32D;">' '</span> + <span style="color: #FA2573;">this</span>.last_name
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">(new_name:String) &#8594; undefined
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Sets the name components of the object, from a full name.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">set_full_name</span>(<span style="color: #729FCF;">new_name</span>) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">names</span>
    names = new_name.trim().split(<span style="color: #A6E32D;">/\s+/</span>)
    <span style="color: #FA2573;">this</span>.first_name = names[0] || <span style="color: #A6E32D;">''</span>
    <span style="color: #FA2573;">this</span>.last_name  = names[1] || <span style="color: #A6E32D;">''</span>
}

Object.defineProperty(mikahil, <span style="color: #A6E32D;">'name'</span>, { get: get_full_name
                                       , set: set_full_name
                                       , writable:     <span style="color: #FA2573;">true</span>
                                       , configurable: <span style="color: #FA2573;">true</span>
                                       , enumerable:   <span style="color: #FA2573;">true</span> })
</pre>



<p>
Now, every-time we try to access the value of Mikhail's <code>name</code> property,
it'll execute the <code>get_full_name</code> getter:
</p>



<pre class="src src-js">mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;'
</span>
mikhail.first_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail'
</span>
mikhail.last_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Wei&#223;'
</span>
mikhail.last_name = <span style="color: #A6E32D;">'White'</span>
mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail White'
</span></pre>



<p>
We can also set the name of the object, by assigning a value to the
property:
</p>



<pre class="src src-js">mikhail.name = <span style="color: #A6E32D;">'Michael White'</span>

mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White'
</span>
mikhail.first_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael'
</span>
mikhail.last_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'White'
</span></pre>




</div>

</div>

<div id="outline-container-1_8" class="outline-3">
<h3 id="sec-1_8">1.8. Listing properties </h3>
<div class="outline-text-3" id="text-1_8">


<p>
Since properties are dynamic, JavaScript provides a way of checking out
which properties an object define. There are two ways of listing the
properties of an object, depending on what kind of properties one is
interested into.
</p>
<p>
The first one is done through a call to <code>Object.getOwnPropertyNames</code>,
which returns an <code>Array</code> containing the names of <b>all</b> properties set in
the object.
</p>
<p>
If we check now what we know about Mikhail:
</p>



<pre class="src src-js">Object.getOwnPropertyNames(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'name', 'age', 'gender', 'first_name', 'last_name' ]
</span></pre>



<p>
The second way is using <code>Object.keys</code>, which returns all properties that
have been marked as <b>enumerable</b> when they were defined:
</p>



<pre class="src src-js">Object.keys(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'name', 'age', 'gender' ]
</span></pre>




</div>

</div>

<div id="outline-container-1_9" class="outline-3">
<h3 id="sec-1_9">1.9. Object literals </h3>
<div class="outline-text-3" id="text-1_9">


<p>
An even easier way of defining objects is to use the object literal
(also called <i>object initialiser</i>) syntax that JavaScript provides. An
object literal denotes a fresh object, that has it's parent as the
<code>Object.prototype</code> object. We'll talk more about parents when we visit
inheritance, later on.
</p>
<p>
At any rate, the object literal syntax allows you to define simple
objects and initialise it with properties at the same time. So, we could
rewrite our Mikhail object to the following:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = { first_name: <span style="color: #A6E32D;">'Mikhail'</span>
              , last_name:  <span style="color: #A6E32D;">'Wei&#223;'</span>
              , age:        19
              , gender:     <span style="color: #A6E32D;">'Male'</span>

              <span style="color: #75766A;">// </span><span style="color: #75766A;">() &#8594; String
</span>              <span style="color: #75766A;">// </span><span style="color: #75766A;">Returns the full name of object.
</span>              , get name() {
                    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.first_name + <span style="color: #A6E32D;">' '</span> + <span style="color: #FA2573;">this</span>.last_name }

              <span style="color: #75766A;">// </span><span style="color: #75766A;">(new_name:String) &#8594; undefined
</span>              <span style="color: #75766A;">// </span><span style="color: #75766A;">Sets the name components of the object,
</span>              <span style="color: #75766A;">// </span><span style="color: #75766A;">from a full name.
</span>              , set name(new_name) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">names</span>
                    names = new_name.trim().split(<span style="color: #A6E32D;">/\s+/</span>)
                    <span style="color: #FA2573;">this</span>.first_name = names[0] || <span style="color: #A6E32D;">''</span>
                    <span style="color: #FA2573;">this</span>.last_name  = names[1] || <span style="color: #A6E32D;">''</span> }
              }
</pre>



<p>
Property names that are not valid identifiers must be quoted. Also note
that the getter/setter notation for object literals strictly defines a
new anonymous function. If you want to assign a previously declared
function to a getter/setter, you need to use the <code>Object.defineProperty</code>
function.
</p>
<p>
The rules for object literal can be described as the following:
</p>



<pre class="src src-bnf"><span style="color: #67D9F0;">&lt;object-literal&gt;</span>  <span style="color: #FA2573;">::=</span> <span style="color: #A6E32D;">"{"</span> <span style="color: #729FCF;">&lt;property-list&gt;</span> <span style="color: #A6E32D;">"}"</span>
                    ;
<span style="color: #67D9F0;">&lt;property-list&gt;</span>   <span style="color: #FA2573;">::=</span> <span style="color: #729FCF;">&lt;property&gt;</span> [<span style="color: #A6E32D;">","</span> <span style="color: #729FCF;">&lt;property&gt;</span>]*
                    ;
<span style="color: #67D9F0;">&lt;property&gt;</span>        <span style="color: #FA2573;">::=</span> <span style="color: #729FCF;">&lt;data-property&gt;</span>
                    <span style="color: #E52222; font-weight: bold;">|</span> <span style="color: #729FCF;">&lt;getter-property&gt;</span>
                    <span style="color: #E52222; font-weight: bold;">|</span> <span style="color: #729FCF;">&lt;setter-property&gt;</span>
                    ;
<span style="color: #67D9F0;">&lt;data-property&gt;</span>   <span style="color: #FA2573;">::=</span> <span style="color: #729FCF;">&lt;property-name&gt;</span> <span style="color: #A6E32D;">":"</span> <span style="color: #729FCF;">&lt;expression&gt;</span>
                    ;
<span style="color: #67D9F0;">&lt;getter-property&gt;</span> <span style="color: #FA2573;">::=</span> <span style="color: #A6E32D;">"get"</span> <span style="color: #729FCF;">&lt;identifier&gt;</span>
                    :       <span style="color: #729FCF;">&lt;function-parameters&gt;</span>
                    :       <span style="color: #729FCF;">&lt;function-block&gt;</span>
                    ;
<span style="color: #67D9F0;">&lt;setter-property&gt;</span> <span style="color: #FA2573;">::=</span> <span style="color: #A6E32D;">"set"</span> <span style="color: #729FCF;">&lt;identifier&gt;</span>
                    :       <span style="color: #729FCF;">&lt;function-parameters&gt;</span>
                    :       <span style="color: #729FCF;">&lt;function-block&gt;</span>
                    ;
<span style="color: #67D9F0;">&lt;property-name&gt;</span>   <span style="color: #FA2573;">::=</span> <span style="color: #729FCF;">&lt;identifier&gt;</span>
                    <span style="color: #E52222; font-weight: bold;">|</span> <span style="color: #729FCF;">&lt;quoted-identifier&gt;</span>
                    ;
</pre>



<p>
Object literals can only appear inside expressions in
JavaScript. Since the syntax is ambiguous to block statements in the
language, new-comers usually confound the two:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">This is a block statement, with a label:
</span>{ foo: <span style="color: #A6E32D;">'bar'</span> }
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'bar'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">This is a syntax error (labels can't be quoted):
</span>{ <span style="color: #A6E32D;">"foo"</span>: <span style="color: #A6E32D;">'bar'</span> }
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; SyntaxError: Invalid label
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">This is an object literal (note the parenthesis to force
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">parsing the contents as an expression):
</span>({ <span style="color: #A6E32D;">"foo"</span>: <span style="color: #A6E32D;">'bar'</span> })
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; { foo: 'bar' }
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">Where the parser is already expecting expressions,
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">object literals don't need to be forced. E.g.:
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">x</span> = { foo: <span style="color: #A6E32D;">'bar'</span> }
fn({foo: <span style="color: #A6E32D;">'bar'</span>})
<span style="color: #C48DFF;">return</span> { foo: <span style="color: #A6E32D;">'bar'</span> }
1, { foo: <span style="color: #A6E32D;">'bar'</span> }
( ... )
</pre>




</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2. Methods </h2>
<div class="outline-text-2" id="text-2">


<p>
Up until now, the Mikhail object only defined slots of concrete data —
with the exception of the name getter/setter. Defining actions that may
be performed on a certain object in JavaScript is just as simple.
</p>
<p>
This is because JavaScript does not differentiate how you can manipulate
a <code>Function</code>, a <code>Number</code> or an <code>Object</code>. Everything is treated the same
way (i.e.: functions in JavaScript are first-class).
</p>
<p>
As such, to define an action for a given object, you just assign a
function object reference to a property. Let's say we wanted a way of
Mikhail to greet someone:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets a random person
</span>mikhail.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Why, hello there, '</span> + person + <span style="color: #A6E32D;">'.'</span>
}
</pre>



<p>
After setting the property, we can use it the same way we used the
concrete data that were assigned to the object. That is, accessing the
property will return a reference to the function object stored there, so
we can just call it:
</p>



<pre class="src src-js">mikhail.greet(<span style="color: #A6E32D;">'you'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Why, hello there, you.'
</span>
mikhail.greet(<span style="color: #A6E32D;">'Kristin'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Why, hello there, Kristin.'
</span></pre>





</div>

<div id="outline-container-2_1" class="outline-3">
<h3 id="sec-2_1">2.1. Dynamic <code>this</code> </h3>
<div class="outline-text-3" id="text-2_1">


<p>
One thing that you must have noticed both on the <code>greet</code> function, and
on the functions we've used for the <code>name</code>'s getter/setter, is that they
use a magical variable called <code>this</code>.
</p>
<p>
This variable is accessible inside any function in JavaScript, and holds
a reference to the object that the function is being applied to. Note
that this does not necessarily means that <code>this</code> will equal the object
where the function is <b>stored</b>.
</p>
<p>
That is, in JavaScript, what <code>this</code> refers to is resolved dynamically,
at the time the function is called, and depending only on how such a
function is called.
</p>
<p>
Having <code>this</code> dynamically resolved is an incredible powerful mechanism
for the dynamism of JavaScript's object orientation and lack of
strictly enforced structures (i.e.: classes), this means one can apply a
function to any object that meets the requirements of the actions it
performs, regardless of how the object has been constructed.
</p>

</div>

</div>

<div id="outline-container-2_2" class="outline-3">
<h3 id="sec-2_2">2.2. How <code>this</code> is resolved </h3>
<div class="outline-text-3" id="text-2_2">


<p>
There are four different ways of resolving the <code>this</code> variable in a
function, depending on how a function is called.
</p>
<p>
For the following examples, we'll take these definitions into account:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(other:Number[, yet_another:Number]) &#8594; Number
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Returns the sum of the object's value with the given Number
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">add</span>(<span style="color: #729FCF;">other</span>, <span style="color: #729FCF;">yet_another</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.value + other + (yet_another || 0)
}

<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">one</span> = { value: 1, add: add }
<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">two</span> = { value: 2, add: add }
</pre>





</div>

<div id="outline-container-2_2_1" class="outline-4">
<h4 id="sec-2_2_1">2.2.1. Called as a method </h4>
<div class="outline-text-4" id="text-2_2_1">


<p>
If a function is called as an object's method, then <code>this</code> inside the
function will refer to the object. That is, when we explicitly state
that an object is carrying an action, then that object will be our
<code>this</code> inside the function.
</p>
<p>
This is what happened when we called <code>mikhail.greet()</code>. The property
access at the time of the call, tells JavaScript that we want to apply
whatever actions the <code>greet</code> function defines to the <code>mikhail</code> object.
</p>



<pre class="src src-js">one.add(two.value) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span>
two.add(3)         <span style="color: #75766A;">// </span><span style="color: #75766A;">this === two
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 5
</span></pre>




</div>

</div>

<div id="outline-container-2_2_2" class="outline-4">
<h4 id="sec-2_2_2">2.2.2. Called directly </h4>
<div class="outline-text-4" id="text-2_2_2">


<p>
When a function is called directly, <code>this</code> will be resolved to the
global object in the engine (e.g.: <code>window</code> in browsers, <code>global</code> in
Node.js)
</p>



<pre class="src src-js">add(two.value)  <span style="color: #75766A;">// </span><span style="color: #75766A;">this === global
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; NaN
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">The global object still has no `value' property, let's fix that.
</span>value = 2
add(two.value)  <span style="color: #75766A;">// </span><span style="color: #75766A;">this === global
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 4
</span></pre>




</div>

</div>

<div id="outline-container-2_2_3" class="outline-4">
<h4 id="sec-2_2_3">2.2.3. Explicitly applied </h4>
<div class="outline-text-4" id="text-2_2_3">


<p>
Finally, a function may be explicitly applied to any object, regardless
of whether the object has the function stored as a property or
not. These applications are done through a either the <code>call</code> or <code>apply</code>
method of a function object.
</p>
<p>
The difference between these two methods is the way they take in the
parameters that will be passed to the function, and the performance —
<code>apply</code> being up to 55x slower than a direct call, whereas <code>call</code> is
usually not as bad. This might vary greatly depending on the engine
though, so it's always better to do a <a href="http://jsperf.com">Perf test</a> rather than being scared
of using this functionality.
</p>
<p>
Anyways, <code>call</code> expects the object that the function will be applied to
as the first parameter, and the parameters to apply to the function as
positional arguments:
</p>



<pre class="src src-js">add.call(two, 2, 2)      <span style="color: #75766A;">// </span><span style="color: #75766A;">this === two
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.call(window, 4)      <span style="color: #75766A;">// </span><span style="color: #75766A;">this === global
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.call(one, one.value) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 2
</span></pre>



<p>
On the other hand, <code>apply</code> lets you pass an array of parameters as the
second parameter of the function. The array will be passed as positional
arguments to the target function:
</p>



<pre class="src src-js">add.apply(two, [2, 2])
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.apply(window, [4])
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.apply(one, [one.value])
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 2
</span></pre>



<dl>
<dt>Note</dt><dd>


<p>
What <code>this</code> resolves to when applying a function to a non-object (like
<code>null</code> or <code>undefined</code>) depends on the semantics used by the
engine. Usually, this would be the same as explicitly applying the
function to the global object. But if the engine is running on <a href="https://developer.mozilla.org/en/JavaScript/Strict_mode">strict mode</a>, then <code>this</code> will be resolved as expected — to the exact thing it
was applied to.
</p>
</dd>
</dl>

</div>
</div>

</div>

<div id="outline-container-2_3" class="outline-3">
<h3 id="sec-2_3">2.3. Bound methods </h3>
<div class="outline-text-3" id="text-2_3">


<p>
Aside from the dynamic nature of functions in JavaScript, there is also
a way of making a function bound to an specific object, such that <code>this</code>
inside that function will always resolve to the given object, regardless
of whether it's called as that object's method or directly.
</p>
<p>
The function that provides such functionality is <code>bind</code>. It takes an
object, and additional parameters (in the same manner as <code>call</code>), and
returns a new function that will apply those parameters to the original
function when called:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">one_add</span> = add.bind(one)

one_add(2) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span>
two.one_adder = one_add
two.one_adder(2) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span>
one_add.call(two) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span></pre>




</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3. Inheritance </h2>
<div class="outline-text-2" id="text-3">


<p>
Up to this point we have seen how objects can define their own
behaviours, and how we can reuse (by explicit application) actions in
other objects, however, this still doesn't give us a nice way for
code reuse and extensibility.
</p>
<p>
That's where inheritance comes in. Inheritance allows for a greater
separation of concerns, where objects define specialised behaviours by
building upon the already defined behaviours of other objects.
</p>
<p>
The prototypical model goes further than that, though, and allows for
selective extensibility, behaviour sharing and other interesting
patterns we'll explore in a bit. Sad thing is: the specific model of
prototypical OO implemented by JavaScript is a bit limited, so
circumventing these limitations to accommodate these patterns will bring
in a bit of overhead sometimes.
</p>


</div>

<div id="outline-container-3_1" class="outline-3">
<h3 id="sec-3_1">3.1. Prototypes </h3>
<div class="outline-text-3" id="text-3_1">


<p>
Inheritance in JavaScript revolves around cloning the behaviours of an
object and extending it with specialised behaviours. The object that has
it's behaviours cloned is called <b>Prototype</b> (not to be confounded with
the <code>prototype</code> property of functions).
</p>
<p>
A prototype is just a plain object, that happens to share it's
behaviours with another object — it acts as the object's parent. It's
important to note here that the concepts of this <i>behaviour cloning</i>
does not imply that you'll have two different copies of the same
function, or data. In fact, JavaScript implements inheritance by
delegation, such that the properties in a prototype are effectively
shared with any object that inherits from it.
</p>
<p>
As mentioned previously, the parent (or Prototype) of an object is
defined by making a call to <code>Object.create</code>, and passing a reference of
the object to use as parent in the first parameter.
</p>
<p>
This would come well in our example up until now. For example, the
greeting and name actions can be well defined in a separate object and
shared with other objects that need them.
</p>
<p>
This would give us the following model:
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-proto-person.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-proto-person.png" />
</p>
<p>
Which could be implemented in JavaScript with the following definitions:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">person</span> = Object.create(<span style="color: #FA2573;">null</span>)

<span style="color: #75766A;">// </span><span style="color: #75766A;">Here we are reusing the previous getter/setter functions
</span>Object.defineProperty(person, <span style="color: #A6E32D;">'name'</span>, { get: get_full_name
                                      , set: set_full_name
                                      , writable:     <span style="color: #FA2573;">true</span>
                                      , configurable: <span style="color: #FA2573;">true</span>
                                      , enumerable:   <span style="color: #FA2573;">true</span> })

<span style="color: #75766A;">// </span><span style="color: #75766A;">And adding the `greet' function
</span>person.greet = <span style="color: #C48DFF;">function</span> (<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Why, hello there, '</span> + person + <span style="color: #A6E32D;">'.'</span>
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Then we can share those behaviours with Mikhail
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = Object.create(person)
mikhail.first_name = <span style="color: #A6E32D;">'Mikhail'</span>
mikhail.last_name  = <span style="color: #A6E32D;">'Wei&#223;'</span>
mikhail.age        = 19
mikhail.gender     = <span style="color: #A6E32D;">'Male'</span>

<span style="color: #75766A;">// </span><span style="color: #75766A;">And we can test whether things are actually working
</span>mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;'
</span>
mikhail.name = <span style="color: #A6E32D;">'Michael White'</span>

mikhail.first_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael'
</span>
mikhail.last_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'White'
</span>
mikhail.greet(<span style="color: #A6E32D;">'you'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Why, hello there, you.'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">And just to be sure, we can check which properties actually
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">belong to `mikhail'
</span>Object.keys(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'first_name', 'last_name', 'age', 'gender' ]
</span></pre>




</div>

</div>

<div id="outline-container-3_2" class="outline-3">
<h3 id="sec-3_2">3.2. How <code>[⁣[Prototype]⁣]</code> works </h3>
<div class="outline-text-3" id="text-3_2">


<p>
As you could see from the previous example, none of the properties
defined in <code>Person</code> have flown to the <code>Mikhail</code> object, and yet we could
access them just fine. This happens because JavaScript implements
delegated property access, that is, a property is searched through all
parents of an object.
</p>
<p>
This parent chain is defined by a hidden slot in every object, called
<code>[⁣[Prototype]⁣]</code>. You can't change this slot directly<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>, so the only
way of setting it is when you're creating a fresh object.
</p>
<p>
When a property is requested from the object, the engine first tries to
retrieve the property from the target object. If the property isn't
found, the search continue through the immediate parent of that object,
and the parent of that parent, and so on.
</p>
<p>
This means that we can change the behaviours of a prototype at run time,
and have it reflected in all objects that inherit from it. For example,
let's suppose we wanted a different default greeting:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person
</span>person.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Harro, '</span> + person + <span style="color: #A6E32D;">'.'</span>
}

mikhail.greet(<span style="color: #A6E32D;">'you'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Harro, you.'
</span></pre>



</div>

</div>

<div id="outline-container-3_3" class="outline-3">
<h3 id="sec-3_3">3.3. Type checking </h3>
<div class="outline-text-3" id="text-3_3">

</div>

</div>

<div id="outline-container-3_4" class="outline-3">
<h3 id="sec-3_4">3.4. Super methods </h3>
<div class="outline-text-3" id="text-3_4">

</div>

</div>

<div id="outline-container-3_5" class="outline-3">
<h3 id="sec-3_5">3.5. Mixins </h3>
<div class="outline-text-3" id="text-3_5">



</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4. Constructors </h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4_1" class="outline-3">
<h3 id="sec-4_1">4.1. The <code>new</code> magic </h3>
<div class="outline-text-3" id="text-4_1">


</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5. Considerations and compatibility </h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5_1" class="outline-3">
<h3 id="sec-5_1">5.1. Creating objects </h3>
<div class="outline-text-3" id="text-5_1">

</div>

</div>

<div id="outline-container-5_2" class="outline-3">
<h3 id="sec-5_2">5.2. Defining properties </h3>
<div class="outline-text-3" id="text-5_2">

</div>

</div>

<div id="outline-container-5_3" class="outline-3">
<h3 id="sec-5_3">5.3. Listing properties </h3>
<div class="outline-text-3" id="text-5_3">

</div>

</div>

<div id="outline-container-5_4" class="outline-3">
<h3 id="sec-5_4">5.4. Bound methods </h3>
<div class="outline-text-3" id="text-5_4">

</div>

</div>

<div id="outline-container-5_5" class="outline-3">
<h3 id="sec-5_5">5.5. Libraries that provide fallbacks </h3>
<div class="outline-text-3" id="text-5_5">


</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">6. Wrapping it up </h2>
<div class="outline-text-2" id="text-6">

</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">7. Things worth reading up next </h2>
<div class="outline-text-2" id="text-7">




</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> : Some implementations have magical names, like <code>__proto__</code>, which
may yield undesired and unwanted results when set. For example,
<code>__proto__</code> property is used to define the parent of an object
in some implementations. As such, you wouldn't be able to set a
string or number to that.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> Some engines <b>do</b> expose the <code>[⁣[Prototype]⁣]</code> slot, usually
through a property like <code>__proto__</code>, however no such thing is
described in the specifications for the language, so it's
recommended that you avoid using it, unless you're well aware
that all platforms you code must run on will have such means of
setting the <code>[⁣[Prototype]⁣]</code> object directly.
</p>
</div>
</div>
