
<p>[TABLE-OF-CONTENTS]
---
layout: post
title:  Understanding JavaScript OOP
snip:   Prototypical inheritance on awesomeness!
---



JavaScript is an object oriented language, with its roots in the <a href="http://selflanguage.org/">Self</a>
programming language, however (sadly) designed to look like Java. This
makes the language's really powerful and sweet features stay covered by
some pretty ugly and counter-intuitive <i>work-arounds</i>.
</p>
<p>
One of such affected features is the implementation of prototypical
inheritance. The concepts are simple yet flexible and powerful. It makes
inheritance and behaviourism first-class citizens, just like functions
are first-class in functional-ish languages (JavaScript included).
</p>
<p>
Fortunately, <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript 5</a> has gotten plenty of things to move the
language in the right way, and it's on those sweetness that this article
will expand on. Though I'll also cover the drawbacks of JavaScript's
design, and do a little comparison with the classical model here and
there, where those would highlight the advantages or disadvantages of
the language's implementation of prototypical OO.
</p>
<p>
It's important to note, though, that this article assumes you have
knowledge over other basic JavaScript functionality, like functions
(including the concepts of closures and first-class functions),
primitive values, operators and such.
</p>



<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1. Objects </h2>
<div class="outline-text-2" id="text-1">


<p>
Everything you can manipulate in JavaScript is an object. This includes
<code>Strings</code>, <code>Arrays</code>, <code>Numbers</code>, <code>Functions</code>, and, obviously, the
so-called <code>Object</code>. An object in the language is simply a collection of
key/value pairs (and a few internal magic sometimes).
</p>
<p>
There are no concepts of classes anywhere, though. That is, an object
with properties <code>name: Linda, age: 21</code> is not an instance of the
<code>Object</code> class. Both <code>Object</code> and <code>Linda</code> are entirely separate
<b>instances</b> that <i>fully</i> define their own behaviour. In JavaScript,
objects are instances of themselves, there are no layers of meta-data
(i.e.: classes) to provide how an object of a certain type must look
like.
</p>
<p>
You might ask: "how?". More so if you come from a highly classical
Object Orientation background (like Java or C#). Wouldn't having each
object define their own behaviour, instead of a common <i>class</i> mean that
if I have 100 objects, I will have 100 different methods? Also, isn't it
dangerous? How would one know if an object is really an Array, for
example?
</p>
<p>
Well, to answer all those questions, we'll first need to unlearn
everything about the classical OO approach and start from the ground
up. But, trust me, it's worth it. The prototypical OO model brings in
some new ways of solving old problems, in an easier and more dynamic
way. It also presents new and more powerful models for extensibility and
code-reuse, which is what most people are interested about when they
talk about Object Orientation.
</p>


</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1">1.1. What are objects? </h3>
<div class="outline-text-3" id="text-1_1">


<p>
As mentioned previously, objects are simple pairs of unique keys that
correspond to a value — we'll call this pair a <code>property</code>. So, suppose
you'd want to describe a few aspects of an old friend — let's call it
<code>Mikhail</code>, like age, name and gender:
</p>



<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-obj-mikhail.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-obj-mikhail.png" />
</p>
<p>
Objects are created in JavaScript using the <code>Object.create</code> function. It
takes a parent and an optional list of property descriptors and makes a
brand new instance. Though, we'll not worry much about the parameters
now.
</p>
<p>
An empty object is an object with no parent, and no properties. The
syntax to create such object in JavaScript is the following:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = Object.create(<span style="color: #FA2573;">null</span>)
</pre>




</div>

</div>

<div id="outline-container-1_2" class="outline-3">
<h3 id="sec-1_2">1.2. Creating properties </h3>
<div class="outline-text-3" id="text-1_2">


<p>
So, now we have an object, but no properties — we've got to fix that if
we want to describe <code>Mikhail</code>.
</p>
<p>
Properties in JavaScript are dynamic. That means that they can be
created or removed at any time. Properties are also unique, in the sense
that a property name inside an object correspond to exactly one value.
</p>
<p>
Creating new properties is done through the <code>Object.defineProperty</code>
function, which takes a reference to an object, the name of the property
to create and a descriptor that defines the semantics of the property.
</p>



<pre class="src src-js">Object.defineProperty(mikhail, <span style="color: #A6E32D;">'name'</span>, { value:        <span style="color: #A6E32D;">'Mikhail'</span>
                                       , writable:     <span style="color: #FA2573;">true</span>
                                       , configurable: <span style="color: #FA2573;">true</span>
                                       , enumerable:   <span style="color: #FA2573;">true</span> })

Object.defineProperty(mikhail, <span style="color: #A6E32D;">'age'</span>, { value:        19
                                      , writable:     <span style="color: #FA2573;">true</span>
                                      , configurable: <span style="color: #FA2573;">true</span>
                                      , enumerable:   <span style="color: #FA2573;">true</span> })

Object.defineProperty(mikhail, <span style="color: #A6E32D;">'gender'</span>, { value:        <span style="color: #A6E32D;">'Male'</span>
                                         , writable:     <span style="color: #FA2573;">true</span>
                                         , configurable: <span style="color: #FA2573;">true</span>
                                         , enumerable:   <span style="color: #FA2573;">true</span> })
</pre>



<p>
<code>Object.defineProperty</code> will create a new property if a property with
the given name does not exist in the object, otherwise it'll update the
semantics and value of the existing property.
</p>

</div>

</div>

<div id="outline-container-1_3" class="outline-3">
<h3 id="sec-1_3">1.3. Descriptors </h3>
<div class="outline-text-3" id="text-1_3">


<p>
Descriptors are the little object that carry the semantics of a property
(we used them in the previous <code>Object.defineProperty</code> calls).
</p>
<p>
A descriptor may be a data descriptor — it holds a concrete value — or
an accessor descriptor — it proxies the access to the concrete value
through getters and setter functions.
</p>
<p>
All the descriptors share the following attributes. Whenever these are
not given, they default to <code>false</code>.
</p>
<dl>
<dt>writable</dt><dd>

<p>
Whether the concrete value of the property may be changed.
</p>
</dd>
<dt>configurable</dt><dd>

<p>
Whether the type of descriptor may be changed, or if the property can
be removed.
</p>
</dd>
<dt>enumerable</dt><dd>

<p>
Whether the property is listed in a loop through the properties of the
object.
</p></dd>
</dl>


<p>
Data descriptors can have the following attribute. Defaults to
<code>undefined</code> when not given.
</p>
<dl>
<dt>value</dt><dd>

<p>
The value of a property.
</p></dd>
</dl>


<p>
Accessor descriptors can have the following attributes. Defaults to
<code>undefined</code> when not given.
</p>
<dl>
<dt>get ()</dt><dd>

<p>
A function called with no arguments when the property value is
requested.
</p>
</dd>
<dt>set (new_value)</dt><dd>

<p>
A function called with the new value for the property when the user
tries to modify the value of the property.
</p>
</dd>
</dl>

</div>

</div>

<div id="outline-container-1_4" class="outline-3">
<h3 id="sec-1_4">1.4. Ditching the verbosity </h3>
<div class="outline-text-3" id="text-1_4">


<p>
Luckily, property descriptors are not the only way of working with
properties in JavaScript, they can also be handled in a sane and concise
way.
</p>
<p>
JavaScript also understands references to a property using what we call
<i>bracket notation</i>. The general rule is:
</p>



<pre class="src src-bnf">&lt;bracket-access&gt; ::= &lt;identifier&gt; <span style="color: #A6E32D;">"["</span> &lt;expression&gt; <span style="color: #A6E32D;">"]"</span>
</pre>



<p>
Where <code>identifier</code> is the variable that holds the object containing the
properties we want to access, and <code>expression</code> is any valid JavaScript
expression that defines the name of the property. There are no
constraints in which name a property can have<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>, everything is fair
game.
</p>
<p>
Thus, we could just as well rewrite our previous example as:
</p>



<pre class="src src-js">mikhail[<span style="color: #A6E32D;">'name'</span>]   = <span style="color: #A6E32D;">'Mikhail'</span>
mikhail[<span style="color: #A6E32D;">'age'</span>]    = 19
mikhail[<span style="color: #A6E32D;">'gender'</span>] = <span style="color: #A6E32D;">'Male'</span>
</pre>



<p>
⁣
</p>
<dl>
<dt>Note</dt><dd>


<p>
All property names are ultimately converted to a String, such that
<code>object[1]</code>, <code>object[⁣[1]⁣]</code>, <code>object['1']</code> and <code>object[variable]</code> (when
the variable resolves to <code>1</code>) are all equivalent.
</p></dd>
</dl>


<p>
There is another way of referring to a property called <i>dot notation</i>, which usually looks better (and presents less syntactical
noises) than the bracket alternative, however it only works when the
property name is a <a href="http://es5.github.com/#x7.6">valid JavaScript identifier</a>, and don't allow
for arbitrary expressions (so, variables here are a no-go).
</p>
<p>
The rule for <i>dot notation</i> is:
</p>



<pre class="src src-bnf">&lt;dot-access&gt; ::= &lt;identifier&gt; <span style="color: #A6E32D;">"."</span> &lt;identifier&gt;
</pre>



<p>
This would give us an even sweeter way of defining properties:
</p>



<pre class="src src-js">mikhail.name   = <span style="color: #A6E32D;">'Mikhail'</span>
mikhail.age    = 19
mikhail.gender = <span style="color: #A6E32D;">'Male'</span>
</pre>



<p>
Both of these syntaxes are equivalent to creating a data property, with
all semantic flags set to <code>true</code>.
</p>

</div>

</div>

<div id="outline-container-1_5" class="outline-3">
<h3 id="sec-1_5">1.5. Accessing properties </h3>
<div class="outline-text-3" id="text-1_5">


<p>
Retrieving the values stored in a given property is as easy as creating
new ones, and the syntax is mostly similar as well — the only difference
being there isn't an assignment.
</p>
<p>
So, if we want to check on Mikhail's age:
</p>



<pre class="src src-js">mikhail[<span style="color: #A6E32D;">'age'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 19
</span></pre>



<p>
Trying to access a property that does not exist in the object simply
returns <code>undefined</code>:
</p>



<pre class="src src-js">mikhail[<span style="color: #A6E32D;">'address'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; undefined
</span></pre>




</div>

</div>

<div id="outline-container-1_6" class="outline-3">
<h3 id="sec-1_6">1.6. Removing properties </h3>
<div class="outline-text-3" id="text-1_6">


<p>
To remove entire properties from an object, JavaScript provides the
<code>delete</code> operator. So, if you wanted to remove the <code>gender</code> property
from the <code>mikhail</code> object:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">delete</span> mikhail[<span style="color: #A6E32D;">'gender'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; true
</span>
mikhail[<span style="color: #A6E32D;">'gender'</span>]
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; undefined
</span></pre>



<p>
The <code>delete</code> operator returns <code>true</code> if the property was removed,
<code>false</code> otherwise. I won't delve into details of the workings of this
operator, since <a href="http://twitter.com/kangax">@kangax</a> has already written a
<a href="http://perfectionkills.com/understanding-delete/">most awesome article on how delete works</a>.
</p>

</div>

</div>

<div id="outline-container-1_7" class="outline-3">
<h3 id="sec-1_7">1.7. Getters and setters </h3>
<div class="outline-text-3" id="text-1_7">


<p>
Getters and setters are usually used in classical object oriented
languages to provide encapsulation. They are not much needed (or wanted)
in JavaScript, though, given how dynamic the language is — <del>and my bias against the feature</del>.
</p>
<p>
At any rate, they allow you to proxy the requests for reading a property
value or setting it, and decide how to handle each situation. So,
suppose we had separate slots for our object's first and last name, but
wanted a simple interface for reading and setting it.
</p>
<p>
First, let's set the first and last names of our friend, as concrete
data properties:
</p>



<pre class="src src-js">Object.defineProperty(mikhail, <span style="color: #A6E32D;">'first_name'</span>, { value:    <span style="color: #A6E32D;">'Mikhail'</span>
                                             , writable: <span style="color: #FA2573;">true</span> })

Object.defineProperty(mikhail, <span style="color: #A6E32D;">'last_name'</span>, { value:    <span style="color: #A6E32D;">'Wei&#223;'</span>
                                            , writable: <span style="color: #FA2573;">true</span> })
</pre>



<p>
Then we can define a common way of accessing and setting both of those
values at the same time — let's call it <code>name</code>:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">() &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Returns the full name of object.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">get_full_name</span>() {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.first_name + <span style="color: #A6E32D;">' '</span> + <span style="color: #FA2573;">this</span>.last_name
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">(new_name:String) &#8594; undefined
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Sets the name components of the object, from a full name.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">set_full_name</span>(<span style="color: #729FCF;">new_name</span>) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">names</span>
    names = new_name.trim().split(<span style="color: #A6E32D;">/\s+/</span>)
    <span style="color: #FA2573;">this</span>.first_name = names[0] || <span style="color: #A6E32D;">''</span>
    <span style="color: #FA2573;">this</span>.last_name  = names[1] || <span style="color: #A6E32D;">''</span>
}

Object.defineProperty(mikahil, <span style="color: #A6E32D;">'name'</span>, { get: get_full_name
                                       , set: set_full_name
                                       , writable:     <span style="color: #FA2573;">true</span>
                                       , configurable: <span style="color: #FA2573;">true</span>
                                       , enumerable:   <span style="color: #FA2573;">true</span> })
</pre>



<p>
Now, every-time we try to access the value of Mikhail's <code>name</code> property,
it'll execute the <code>get_full_name</code> getter:
</p>



<pre class="src src-js">mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;'
</span>
mikhail.first_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail'
</span>
mikhail.last_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Wei&#223;'
</span>
mikhail.last_name = <span style="color: #A6E32D;">'White'</span>
mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail White'
</span></pre>



<p>
We can also set the name of the object, by assigning a value to the
property:
</p>



<pre class="src src-js">mikhail.name = <span style="color: #A6E32D;">'Michael White'</span>

mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White'
</span>
mikhail.first_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael'
</span>
mikhail.last_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'White'
</span></pre>




</div>

</div>

<div id="outline-container-1_8" class="outline-3">
<h3 id="sec-1_8">1.8. Listing properties </h3>
<div class="outline-text-3" id="text-1_8">


<p>
Since properties are dynamic, JavaScript provides a way of checking out
which properties an object define. There are two ways of listing the
properties of an object, depending on what kind of properties one is
interested into.
</p>
<p>
The first one is done through a call to <code>Object.getOwnPropertyNames</code>,
which returns an <code>Array</code> containing the names of <b>all</b> properties set in
the object.
</p>
<p>
If we check now what we know about Mikhail:
</p>



<pre class="src src-js">Object.getOwnPropertyNames(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'name', 'age', 'gender', 'first_name', 'last_name' ]
</span></pre>



<p>
The second way is using <code>Object.keys</code>, which returns all properties that
have been marked as <b>enumerable</b> when they were defined:
</p>



<pre class="src src-js">Object.keys(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'name', 'age', 'gender' ]
</span></pre>




</div>

</div>

<div id="outline-container-1_9" class="outline-3">
<h3 id="sec-1_9">1.9. Object literals </h3>
<div class="outline-text-3" id="text-1_9">


<p>
An even easier way of defining objects is to use the object literal
(also called <i>object initialiser</i>) syntax that JavaScript provides. An
object literal denotes a fresh object, that has it's parent as the
<code>Object.prototype</code> object. We'll talk more about parents when we visit
inheritance, later on.
</p>
<p>
At any rate, the object literal syntax allows you to define simple
objects and initialise it with properties at the same time. So, we could
rewrite our Mikhail object to the following:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = { first_name: <span style="color: #A6E32D;">'Mikhail'</span>
              , last_name:  <span style="color: #A6E32D;">'Wei&#223;'</span>
              , age:        19
              , gender:     <span style="color: #A6E32D;">'Male'</span>

              <span style="color: #75766A;">// </span><span style="color: #75766A;">() &#8594; String
</span>              <span style="color: #75766A;">// </span><span style="color: #75766A;">Returns the full name of object.
</span>              , get name() {
                    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.first_name + <span style="color: #A6E32D;">' '</span> + <span style="color: #FA2573;">this</span>.last_name }

              <span style="color: #75766A;">// </span><span style="color: #75766A;">(new_name:String) &#8594; undefined
</span>              <span style="color: #75766A;">// </span><span style="color: #75766A;">Sets the name components of the object,
</span>              <span style="color: #75766A;">// </span><span style="color: #75766A;">from a full name.
</span>              , set name(new_name) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">names</span>
                    names = new_name.trim().split(<span style="color: #A6E32D;">/\s+/</span>)
                    <span style="color: #FA2573;">this</span>.first_name = names[0] || <span style="color: #A6E32D;">''</span>
                    <span style="color: #FA2573;">this</span>.last_name  = names[1] || <span style="color: #A6E32D;">''</span> }
              }
</pre>



<p>
Property names that are not valid identifiers must be quoted. Also note
that the getter/setter notation for object literals strictly defines a
new anonymous function. If you want to assign a previously declared
function to a getter/setter, you need to use the <code>Object.defineProperty</code>
function.
</p>
<p>
The rules for object literal can be described as the following:
</p>



<pre class="src src-bnf">&lt;object-literal&gt;  ::= <span style="color: #A6E32D;">"{"</span> &lt;property-list&gt; <span style="color: #A6E32D;">"}"</span>
                    ;
&lt;property-list&gt;   ::= &lt;property&gt; [<span style="color: #A6E32D;">","</span> &lt;property&gt;]*
                    ;
&lt;property&gt;        ::= &lt;data-property&gt;
                    | &lt;getter-property&gt;
                    | &lt;setter-property&gt;
                    ;
&lt;data-property&gt;   ::= &lt;property-name&gt; <span style="color: #A6E32D;">":"</span> &lt;expression&gt;
                    ;
&lt;getter-property&gt; ::= <span style="color: #A6E32D;">"get"</span> &lt;identifier&gt;
                    :       &lt;function-parameters&gt;
                    :       &lt;function-block&gt;
                    ;
&lt;setter-property&gt; ::= <span style="color: #A6E32D;">"set"</span> &lt;identifier&gt;
                    :       &lt;function-parameters&gt;
                    :       &lt;function-block&gt;
                    ;
&lt;property-name&gt;   ::= &lt;identifier&gt;
                    | &lt;quoted-identifier&gt;
                    ;
</pre>



<p>
Object literals can only appear inside expressions in
JavaScript. Since the syntax is ambiguous to block statements in the
language, new-comers usually confound the two:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">This is a block statement, with a label:
</span>{ foo: <span style="color: #A6E32D;">'bar'</span> }
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'bar'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">This is a syntax error (labels can't be quoted):
</span>{ <span style="color: #A6E32D;">"foo"</span>: <span style="color: #A6E32D;">'bar'</span> }
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; SyntaxError: Invalid label
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">This is an object literal (note the parenthesis to force
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">parsing the contents as an expression):
</span>({ <span style="color: #A6E32D;">"foo"</span>: <span style="color: #A6E32D;">'bar'</span> })
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; { foo: 'bar' }
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">Where the parser is already expecting expressions,
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">object literals don't need to be forced. E.g.:
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">x</span> = { foo: <span style="color: #A6E32D;">'bar'</span> }
fn({foo: <span style="color: #A6E32D;">'bar'</span>})
<span style="color: #C48DFF;">return</span> { foo: <span style="color: #A6E32D;">'bar'</span> }
1, { foo: <span style="color: #A6E32D;">'bar'</span> }
( ... )
</pre>




</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2. Methods </h2>
<div class="outline-text-2" id="text-2">


<p>
Up until now, the Mikhail object only defined slots of concrete data —
with the exception of the name getter/setter. Defining actions that may
be performed on a certain object in JavaScript is just as simple.
</p>
<p>
This is because JavaScript does not differentiate how you can manipulate
a <code>Function</code>, a <code>Number</code> or an <code>Object</code>. Everything is treated the same
way (i.e.: functions in JavaScript are first-class).
</p>
<p>
As such, to define an action for a given object, you just assign a
function object reference to a property. Let's say we wanted a way of
Mikhail to greet someone:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets a random person
</span>mikhail.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Why, hello there, '</span> + person + <span style="color: #A6E32D;">'.'</span>
}
</pre>



<p>
After setting the property, we can use it the same way we used the
concrete data that were assigned to the object. That is, accessing the
property will return a reference to the function object stored there, so
we can just call it:
</p>



<pre class="src src-js">mikhail.greet(<span style="color: #A6E32D;">'you'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Why, hello there, you.'
</span>
mikhail.greet(<span style="color: #A6E32D;">'Kristin'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Why, hello there, Kristin.'
</span></pre>





</div>

<div id="outline-container-2_1" class="outline-3">
<h3 id="sec-2_1">2.1. Dynamic <code>this</code> </h3>
<div class="outline-text-3" id="text-2_1">


<p>
One thing that you must have noticed both on the <code>greet</code> function, and
on the functions we've used for the <code>name</code>'s getter/setter, is that they
use a magical variable called <code>this</code>.
</p>
<p>
This variable is accessible inside any function in JavaScript, and holds
a reference to the object that the function is being applied to. Note
that this does not necessarily means that <code>this</code> will equal the object
where the function is <b>stored</b>.
</p>
<p>
That is, in JavaScript, what <code>this</code> refers to is resolved dynamically,
at the time the function is called, and depending only on how such a
function is called.
</p>
<p>
Having <code>this</code> dynamically resolved is an incredible powerful mechanism
for the dynamism of JavaScript's object orientation and lack of
strictly enforced structures (i.e.: classes), this means one can apply a
function to any object that meets the requirements of the actions it
performs, regardless of how the object has been constructed.
</p>

</div>

</div>

<div id="outline-container-2_2" class="outline-3">
<h3 id="sec-2_2">2.2. How <code>this</code> is resolved </h3>
<div class="outline-text-3" id="text-2_2">


<p>
There are four different ways of resolving the <code>this</code> variable in a
function, depending on how a function is called.
</p>
<p>
For the following examples, we'll take these definitions into account:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(other:Number[, yet_another:Number]) &#8594; Number
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Returns the sum of the object's value with the given Number
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">add</span>(<span style="color: #729FCF;">other</span>, <span style="color: #729FCF;">yet_another</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.value + other + (yet_another || 0)
}

<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">one</span> = { value: 1, add: add }
<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">two</span> = { value: 2, add: add }
</pre>





</div>

<div id="outline-container-2_2_1" class="outline-4">
<h4 id="sec-2_2_1">2.2.1. Called as a method </h4>
<div class="outline-text-4" id="text-2_2_1">


<p>
If a function is called as an object's method, then <code>this</code> inside the
function will refer to the object. That is, when we explicitly state
that an object is carrying an action, then that object will be our
<code>this</code> inside the function.
</p>
<p>
This is what happened when we called <code>mikhail.greet()</code>. The property
access at the time of the call, tells JavaScript that we want to apply
whatever actions the <code>greet</code> function defines to the <code>mikhail</code> object.
</p>



<pre class="src src-js">one.add(two.value) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span>
two.add(3)         <span style="color: #75766A;">// </span><span style="color: #75766A;">this === two
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 5
</span></pre>




</div>

</div>

<div id="outline-container-2_2_2" class="outline-4">
<h4 id="sec-2_2_2">2.2.2. Called directly </h4>
<div class="outline-text-4" id="text-2_2_2">


<p>
When a function is called directly, <code>this</code> will be resolved to the
global object in the engine (e.g.: <code>window</code> in browsers, <code>global</code> in
Node.js)
</p>



<pre class="src src-js">add(two.value)  <span style="color: #75766A;">// </span><span style="color: #75766A;">this === global
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; NaN
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">The global object still has no `value' property, let's fix that.
</span>value = 2
add(two.value)  <span style="color: #75766A;">// </span><span style="color: #75766A;">this === global
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 4
</span></pre>




</div>

</div>

<div id="outline-container-2_2_3" class="outline-4">
<h4 id="sec-2_2_3">2.2.3. Explicitly applied </h4>
<div class="outline-text-4" id="text-2_2_3">


<p>
Finally, a function may be explicitly applied to any object, regardless
of whether the object has the function stored as a property or
not. These applications are done through a either the <code>call</code> or <code>apply</code>
method of a function object.
</p>
<p>
The difference between these two methods is the way they take in the
parameters that will be passed to the function, and the performance —
<code>apply</code> being up to 55x slower than a direct call, whereas <code>call</code> is
usually not as bad. This might vary greatly depending on the engine
though, so it's always better to do a <a href="http://jsperf.com">Perf test</a> rather than being scared
of using this functionality.
</p>
<p>
Anyways, <code>call</code> expects the object that the function will be applied to
as the first parameter, and the parameters to apply to the function as
positional arguments:
</p>



<pre class="src src-js">add.call(two, 2, 2)      <span style="color: #75766A;">// </span><span style="color: #75766A;">this === two
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.call(window, 4)      <span style="color: #75766A;">// </span><span style="color: #75766A;">this === global
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.call(one, one.value) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 2
</span></pre>



<p>
On the other hand, <code>apply</code> lets you pass an array of parameters as the
second parameter of the function. The array will be passed as positional
arguments to the target function:
</p>



<pre class="src src-js">add.apply(two, [2, 2])
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.apply(window, [4])
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 6
</span>
add.apply(one, [one.value])
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 2
</span></pre>



<dl>
<dt>Note</dt><dd>


<p>
What <code>this</code> resolves to when applying a function to a non-object (like
<code>null</code> or <code>undefined</code>) depends on the semantics used by the
engine. Usually, this would be the same as explicitly applying the
function to the global object. But if the engine is running on <a href="https://developer.mozilla.org/en/JavaScript/Strict_mode">strict mode</a>, then <code>this</code> will be resolved as expected — to the exact thing it
was applied to.
</p>
</dd>
</dl>

</div>
</div>

</div>

<div id="outline-container-2_3" class="outline-3">
<h3 id="sec-2_3">2.3. Bound methods </h3>
<div class="outline-text-3" id="text-2_3">


<p>
Aside from the dynamic nature of functions in JavaScript, there is also
a way of making a function bound to an specific object, such that <code>this</code>
inside that function will always resolve to the given object, regardless
of whether it's called as that object's method or directly.
</p>
<p>
The function that provides such functionality is <code>bind</code>. It takes an
object, and additional parameters (in the same manner as <code>call</code>), and
returns a new function that will apply those parameters to the original
function when called:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">one_add</span> = add.bind(one)

one_add(2) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span>
two.one_adder = one_add
two.one_adder(2) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span>
one_add.call(two) <span style="color: #75766A;">// </span><span style="color: #75766A;">this === one
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 3
</span></pre>




</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3. Inheritance </h2>
<div class="outline-text-2" id="text-3">


<p>
Up to this point we have seen how objects can define their own
behaviours, and how we can reuse (by explicit application) actions in
other objects, however, this still doesn't give us a nice way for
code reuse and extensibility.
</p>
<p>
That's where inheritance comes in. Inheritance allows for a greater
separation of concerns, where objects define specialised behaviours by
building upon the already defined behaviours of other objects.
</p>
<p>
The prototypical model goes further than that, though, and allows for
selective extensibility, behaviour sharing and other interesting
patterns we'll explore in a bit. Sad thing is: the specific model of
prototypical OO implemented by JavaScript is a bit limited, so
circumventing these limitations to accommodate these patterns will bring
in a bit of overhead sometimes.
</p>


</div>

<div id="outline-container-3_1" class="outline-3">
<h3 id="sec-3_1">3.1. Prototypes </h3>
<div class="outline-text-3" id="text-3_1">


<p>
Inheritance in JavaScript revolves around cloning the behaviours of an
object and extending it with specialised behaviours. The object that has
it's behaviours cloned is called <b>Prototype</b> (not to be confounded with
the <code>prototype</code> property of functions).
</p>
<p>
A prototype is just a plain object, that happens to share it's
behaviours with another object — it acts as the object's parent. It's
important to note here that the concepts of this <i>behaviour cloning</i>
does not imply that you'll have two different copies of the same
function, or data. In fact, JavaScript implements inheritance by
delegation, such that the properties in a prototype are effectively
shared with any object that inherits from it.
</p>
<p>
As mentioned previously, the parent (or Prototype) of an object is
defined by making a call to <code>Object.create</code>, and passing a reference of
the object to use as parent in the first parameter.
</p>
<p>
This would come well in our example up until now. For example, the
greeting and name actions can be well defined in a separate object and
shared with other objects that need them.
</p>
<p>
This would give us the following model:
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-proto-person.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-proto-person.png" />
</p>
<p>
Which could be implemented in JavaScript with the following definitions:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">person</span> = Object.create(<span style="color: #FA2573;">null</span>)

<span style="color: #75766A;">// </span><span style="color: #75766A;">Here we are reusing the previous getter/setter functions
</span>Object.defineProperty(person, <span style="color: #A6E32D;">'name'</span>, { get: get_full_name
                                      , set: set_full_name
                                      , writable:     <span style="color: #FA2573;">true</span>
                                      , configurable: <span style="color: #FA2573;">true</span>
                                      , enumerable:   <span style="color: #FA2573;">true</span> })

<span style="color: #75766A;">// </span><span style="color: #75766A;">And adding the `greet' function
</span>person.greet = <span style="color: #C48DFF;">function</span> (<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Why, hello there, '</span> + person + <span style="color: #A6E32D;">'.'</span>
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Then we can share those behaviours with Mikhail
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = Object.create(person)
mikhail.first_name = <span style="color: #A6E32D;">'Mikhail'</span>
mikhail.last_name  = <span style="color: #A6E32D;">'Wei&#223;'</span>
mikhail.age        = 19
mikhail.gender     = <span style="color: #A6E32D;">'Male'</span>

<span style="color: #75766A;">// </span><span style="color: #75766A;">And we can test whether things are actually working
</span>mikhail.name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;'
</span>
mikhail.name = <span style="color: #A6E32D;">'Michael White'</span>

mikhail.first_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael'
</span>
mikhail.last_name
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'White'
</span>
mikhail.greet(<span style="color: #A6E32D;">'you'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Why, hello there, you.'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">And just to be sure, we can check which properties actually
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">belong to `mikhail'
</span>Object.keys(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'first_name', 'last_name', 'age', 'gender' ]
</span></pre>




</div>

</div>

<div id="outline-container-3_2" class="outline-3">
<h3 id="sec-3_2">3.2. How <code>[⁣[Prototype]⁣]</code> works </h3>
<div class="outline-text-3" id="text-3_2">


<p>
As you could see from the previous example, none of the properties
defined in <code>Person</code> have flown to the <code>Mikhail</code> object, and yet we could
access them just fine. This happens because JavaScript implements
delegated property access, that is, a property is searched through all
parents of an object.
</p>
<p>
This parent chain is defined by a hidden slot in every object, called
<code>[⁣[Prototype]⁣]</code>. You can't change this slot directly<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>, so the only
way of setting it is when you're creating a fresh object.
</p>
<p>
When a property is requested from the object, the engine first tries to
retrieve the property from the target object. If the property isn't
found, the search continue through the immediate parent of that object,
and the parent of that parent, and so on.
</p>
<p>
This means that we can change the behaviours of a prototype at run time,
and have it reflected in all objects that inherit from it. For example,
let's suppose we wanted a different default greeting:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person
</span>person.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Harro, '</span> + person + <span style="color: #A6E32D;">'.'</span>
}

mikhail.greet(<span style="color: #A6E32D;">'you'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Michael White: Harro, you.'
</span></pre>



</div>

</div>

<div id="outline-container-3_3" class="outline-3">
<h3 id="sec-3_3">3.3. Overriding properties </h3>
<div class="outline-text-3" id="text-3_3">

<p>So, prototypes (that is, inheritance) are used for sharing data with
other objects, and it does such in a pretty fast and memory-effective
manner too, since you'll always have only one instance of a given piece
of data laying around.
</p>
<p>
Now what if we want to add specialised behaviours, that build upon the
data that was shared with the object? Well, we have seen before that
objects define their own behaviours by defining properties, so
specialised behaviours follow the same principle — you just define the
new behaviour.
</p>
<p>
To better demonstrate it, suppose <code>Person</code> implements only a general
greeting, and everyone inheriting from <code>Person</code> (by which I mean,
sharing its behaviours). Also, let's add a new person to our case
scenario, so to outline better how objects are extended:
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-extend.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-extend.png" />
</p>
<p>
Note that both <code>mikhail</code> and <code>kristin</code> define their own version of
<code>greet</code>. In this case, whenever we call the <code>greet</code> method on them
they'll use their own version of that behaviour, instead of the one that
was shared from <code>person</code>.
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">Here we set up the greeting for a generic person
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person, formally
</span>person.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Hello, '</span> + (person || <span style="color: #A6E32D;">'you'</span>)
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">And a greeting for our protagonist, Mikhail
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person, like a bro
</span>mikhail.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': \'sup, '</span> + (person || <span style="color: #A6E32D;">'dude'</span>)
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">And finally we define our new protagonist, Kristin
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">kristin</span> = Object.create(person)
kristin.first_name = <span style="color: #A6E32D;">'Kristin'</span>
kristin.last_name  = <span style="color: #A6E32D;">'Wei&#223;'</span>
kristin.age        = 19
kristin.gender     = <span style="color: #A6E32D;">'Female'</span>

<span style="color: #75766A;">// </span><span style="color: #75766A;">Alongside with her specific greeting manners
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person, sweetly
</span>kristin.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': \'ello, '</span> + (person || <span style="color: #A6E32D;">'sweetie'</span>)
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Finally, we test if everything works according to the expected
</span>
mikhail.greet(kristin.name)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: \'sup, Kristin Wei&#223;'
</span>
mikhail.greet()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: \'sup, dude'
</span>
kristin.greet(mikhail.name)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Kristin Wei&#223;: \'ello, Mikhail Wei&#223;'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">And just so we check how cool this [[Prototype]] thing is,
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">let's get Kristin back to the generic behaviour
</span>
<span style="color: #C48DFF;">delete</span> kristin.greet
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; true
</span>
kristin.greet(mikhail.name)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Kristin Wei&#223;: Hello, Mikhail Wei&#223;'
</span></pre>




</div>

</div>

<div id="outline-container-3_4" class="outline-3">
<h3 id="sec-3_4">3.4. Mixins </h3>
<div class="outline-text-3" id="text-3_4">

<p>Prototypes allow for behaviour sharing in JavaScript, and although they
are undeniably powerful, they aren't quite as powerful as they could
be. For one, prototypes only allow that one object inherit from another
single object, while extending those behaviours as they see fit.
</p>
<p>
However, this approach quickly kills interesting things like behaviour
composition, where we could mix-and-match several objects into one, with
all the advantages highlighted in the prototypical inheritance.
</p>
<p>
Multiple inheritance would also allow the usage of <i>data-parents</i> —
objects that provide an example state that fulfils the requirements for
a given behaviour. Default properties, if you will.
</p>
<p>
Luckily, since we can define behaviours directly on an object in
JavaScript, we can work-around these issues by using mixins — and adding
a little overhead at object's creation time.
</p>
<p>
So, what are mixins anyways? Well, they are parent-less objects. That
is, they fully define their own behaviour, and are mostly designed to be
incorporated in other objects (although you could use their methods
directly).
</p>
<p>
Continuing with our little protagonists' scenario, let's extend it to
add some capabilities to them. Let's say that every person can also be a
<code>pianist</code> or a <code>singer</code>. A given person can have no such abilities, be
just a pianist, just a singer or both. This is the kind of case where
JavaScript's model of prototypical inheritance falls short, so we're
going to cheat a little bit.
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-mixins.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-mixins.png" />
</p>
<p>
For mixins to work, we first need to have a way of combining different
objects into a single one. JavaScript doesn't provide this out-of-the
box, but we can easily make one by copying all <b>own</b> (the ones defined
directly in the object, rather than inherited) property descriptors of
an object over to another.
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">Aliases for the rather verbose methods on ES5
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">descriptor</span>  = Object.getOwnPropertyDescriptor
  , properties  = Object.getOwnPropertyNames
  , define_prop = Object.defineProperty

<span style="color: #75766A;">// </span><span style="color: #75766A;">(target:Object, source:Object) &#8594; Object
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Copies properties from `source' to `target'
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">extend</span>(<span style="color: #729FCF;">target</span>, <span style="color: #729FCF;">source</span>) {
    properties(source).forEach(<span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">key</span>) {
        define_prop(target, key, descriptor(source, key)) })

    <span style="color: #C48DFF;">return</span> target
}
</pre>



<p>
Basically, what <code>extend</code> does here is taking two objects — a source and
a target, — iterating over all properties present on the <code>source</code>
object, and copying the property descriptors over to <code>target</code>. Note that
this is a destructive method, meaning that <code>target</code> will be modified
in-place. It's the cheapest way, though, and usually not a problem.
</p>
<p>
Now that we have a method for copying properties over, we can start
assigning multiple abilities to our objects (<code>mikhail</code> e
<code>kristin</code>):
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">A pianist is someone who can `play' the piano
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">pianist</span> = Object.create(<span style="color: #FA2573;">null</span>)
pianist.play = <span style="color: #C48DFF;">function</span>() {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name <span style="color: #A6E32D;">' starts playing the piano.'</span>
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">A singer is someone who can `sing'
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">singer</span> = Object.create(<span style="color: #FA2573;">null</span>)
singer.sing = <span style="color: #C48DFF;">function</span>() {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">' starts singing.'</span>
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Then we can move on to adding those abilities to
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">our main objects:
</span>extend(mikhail, pianist)
mikhail.play()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223; starts playing the piano.'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">We can see that all that ends up as an own property of
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">mikhail. It is not shared.
</span>Object.keys(mikhail)
[<span style="color: #A6E32D;">'first_name'</span>, <span style="color: #A6E32D;">'last_name'</span>, <span style="color: #A6E32D;">'age'</span>, <span style="color: #A6E32D;">'gender'</span>, <span style="color: #A6E32D;">'greet'</span>, <span style="color: #A6E32D;">'play'</span>]

<span style="color: #75766A;">// </span><span style="color: #75766A;">Then we can define kristin as a singer
</span>extend(kristin, singer)
kristin.sing()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Kristin Wei&#223; starts singing.'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">Mikhail can't sing yet though
</span>mikhail.sing()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; TypeError: Object #&lt;Object&gt; has no method 'sing'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">But mikhail will inherit the `sing' method if we
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">extend the Person prototype with it:
</span>extend(person, singer)

mikhail.sing()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223; starts singing'
</span></pre>






</div>

</div>

<div id="outline-container-3_5" class="outline-3">
<h3 id="sec-3_5">3.5. Resending messages </h3>
<div class="outline-text-3" id="text-3_5">

<p>Now that we're able to inherit properties from other objects and extend
the specialised objects to define their own behaviours, we have a little
problem: what if we actually wanted to access the parent behaviours that
we just overwrote?
</p>
<p>
A naïve solution would be to just access the parent's property, or apply
the parent's method to the specialised object:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(name:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets someone intimately if we know them, otherwise use
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">the generic greeting
</span>mikhail.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">name</span>) {
    <span style="color: #C48DFF;">return</span> name == <span style="color: #A6E32D;">'Kristin Wei&#223;'</span>?  <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Heya, Kristty'</span>
         : <span style="color: #75766A;">/* </span><span style="color: #75766A;">we dunno this guy */</span>  person.greet.call(<span style="color: #FA2573;">this</span>, name)
}

mikhail.greet(kristin.name)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: Heya, Kristty'
</span>
mikhail.greet(<span style="color: #A6E32D;">'Margareth'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: Hello, Margareth'
</span></pre>



<p>
It apparently works, but this has many short-comings. The most
outstanding of them being that functions don't belong to objects in
JavaScript, so we could assign <code>greet</code> to any object, that provides the
interface the function expects — in this case, an object with a <code>name</code>
property.
</p>
<p>
This other object does not necessarily need to inherit directly from
<code>Person</code>. It might be just about <b>any</b> object, and in this case it would
make more sense that the message were sent to that object's parent,
instead of <code>Person</code> directly. In fact, <code>Person</code> might not be present in
the prototype of this object at all!
</p>
<p>
So, a better description of this issue would be that, when an object
receive a message (property access or method invokation), we might want
to preserve the parent's behaviour under some conditions. Thus, we need:
</p>
<p>
1.) A way of getting the closest parent of an object that implements
the message we're interested in.
</p>
<p>
2.) In the case of methods, a way of applying such behaviour to the
current object.
</p>
<p>
The first one is pretty easy to solve, since JavaScript offers the
<code>Object.getPrototypeOf</code> function for returning the immediate parent of
an object (that is, its <code>[⁣[Prototype]⁣]</code>).
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">slice</span> = [].slice
  , proto = Object.getPrototypeOf


<span style="color: #75766A;">// </span><span style="color: #75766A;">(object:Object) &#8594; Boolean
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Tests if an object can be called (has [[Call]])
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">callablep</span>(<span style="color: #729FCF;">object</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #C48DFF;">typeof</span> object == <span style="color: #A6E32D;">'function'</span>
}


<span style="color: #75766A;">// </span><span style="color: #75766A;">(object:Object, message:String, args...) &#8594; *mixed*
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Resends the given message to the closest parent of `object'
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">that implements it.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">resend</span>(<span style="color: #729FCF;">object</span>, <span style="color: #729FCF;">message</span>) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">args</span>, <span style="color: #729FCF;">property</span>
    args     = slice.call(<span style="color: #FA2573;">arguments</span>, 2)
    property = proto(object)[message]

    <span style="color: #C48DFF;">return</span> callablep(property)?  property.apply(object, args)
         : <span style="color: #75766A;">/* </span><span style="color: #75766A;">data property */</span>   property
}
</pre>



<p>
Now, let's move our greeting function over to a mixin, and make it all a
little more generic. We'll have a <code>greeter</code> mixin, that either calls a
<code>friendly_greet</code> in the object, if the person is known, or a fallback
<code>greet</code> method in the parent.
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(array:Array, value) &#8594; Boolean
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Test if the array includes the value
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">hasp</span>(<span style="color: #729FCF;">array</span>, <span style="color: #729FCF;">value</span>) {
    <span style="color: #C48DFF;">return</span> array.indexOf(value) != -1
}


<span style="color: #75766A;">// </span><span style="color: #75766A;">A greeter is an object that has a list of known people, and
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">it might greet those people in a friendly manner, but only
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">if a specialised behaviour is defined for this (friendly_greet).
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Otherwise it just goes back to formal greeting.
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">greeter</span> = {
    <span style="color: #75766A;">// </span><span style="color: #75766A;">A list of objects we know about
</span>    known: [ ]

    <span style="color: #75766A;">// </span><span style="color: #75766A;">(person:+Person) &#8594; String
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the person intimately, if known, otherwise formally.
</span>    <span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">greet</span>(<span style="color: #729FCF;">person</span>) {
        <span style="color: #75766A;">// </span><span style="color: #75766A;">If we know the person and wish to greet known people
</span>        <span style="color: #75766A;">// </span><span style="color: #75766A;">in a friendly and informal manner
</span>        <span style="color: #C48DFF;">if</span> ( hasp(<span style="color: #FA2573;">this</span>.known, person)
          &amp;&amp; callablep(<span style="color: #FA2573;">this</span>.friendly_greet))
            <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.friendly_greet(person)

        <span style="color: #75766A;">// </span><span style="color: #75766A;">Otherwise we just fallback to formal greeting (probably
</span>        <span style="color: #75766A;">// </span><span style="color: #75766A;">defined in the object's parent)
</span>        <span style="color: #C48DFF;">return</span> resend(<span style="color: #FA2573;">this</span>, <span style="color: #A6E32D;">'greet'</span>, person)
    }
}
</pre>



<p>
We have to update the <code>Person</code>'s greet to accept an object implimenting
the person interface, rather than just a String. And finally, we need to
extend both Mikhail and Kristin with the <code>greeter</code> mixin.
</p>
<p>
Note that we need to redefine the <code>known</code> array here, since otherwise
we'd use the <code>greeter</code>'s array (objects are always copied by reference
rather than by value).
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">We have to update the Person's greet to accept an object
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">implementing the person interface, rather than just a String
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:+Person) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the person formally.
</span>person.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Hello, '</span> + person.name
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">And finally, we make both Mikhail and Kristin greeter-fags
</span>extend(mikhail, greeter)
mikhail.known = [kristin]

<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:+Person) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the person informally.
</span>mikhail.friendly_greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Heya, '</span> + person.first_name
}

extend(kristin, greeter)

<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:+Person) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the person informally.
</span>kristin.friendly_greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Harro, '</span> + person.first_name
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">And we can see that mikhail gets informal greeting right, whereas
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">kristing fallbacks.
</span>mikhail.greet(kristin)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: Heya, Kristin'
</span>
mikhail.greet({name: <span style="color: #A6E32D;">'Margareth'</span>})
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: Hello, Margareth'
</span>
kristin.greet(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Kristin Wei&#223;: Hello, Mikhail Wei&#223;'
</span>
kristin.greet({name: <span style="color: #A6E32D;">'Margareth'</span>})
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Kristin Wei&#223;: Hello, Margareth'
</span>
<span style="color: #75766A;">// </span><span style="color: #75766A;">Though, if we include `mikhail' in the list of known people, we
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">get friendly greetings as well for Kristin:
</span>kristin.known = [mikhail]
kristin.greet(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Kristin Wei&#223;: Harro, Mikhail'
</span></pre>



<p>
This looks all good and well, but there's a little catch in the current
implementation of message resending: it will enter in endless recursion if you
try to apply it to more than one parent. This happens because the methods are
always applied in the context of the message's first target, making the
<code>[⁣[Prototype]⁣]</code> lookup resolve always to the same object:
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-super.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-super.png" />
</p>
<p>
For the <code>resend</code> function to work correctly, it has to know what the
next object in the prototype chain is, thus, we can't blindly use the
<code>this</code> value for the look-up. Instead, we have to pass this information
somehow over to the <code>resend</code> function.
</p>
<p>
Given the only pieces of information we can pass to a function are the
<code>thisObject</code> and <code>arguments</code>, we'll going to abuse the former here, as
the latter would involve changing the signature of all functions.
</p>
<p>
The idea is that, when we call a method in the parent, we store the
reference to that parent in the current <code>thisObject</code> so we know where to
start looking for next:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(object:Object, message:String, args...) &#8594; *mixed*
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Resends the given message to the closest parent of `object'
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">that implements it.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">resend</span>(<span style="color: #729FCF;">object</span>, <span style="color: #729FCF;">message</span>) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">args</span>, <span style="color: #729FCF;">property</span>, <span style="color: #729FCF;">result</span>
    args = slice.call(<span style="color: #FA2573;">arguments</span>, 2)

    <span style="color: #75766A;">// </span><span style="color: #75766A;">Store the next parent on the prototype chain. Try to
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">look for the one stored in object.$parent, falling
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">back to the object itself.
</span>    object.$parent = proto(object.$parent || object)

    <span style="color: #75766A;">// </span><span style="color: #75766A;">Get the property from the next prototype
</span>    property = object.$parent[message]

    <span style="color: #75766A;">// </span><span style="color: #75766A;">Calculates the result that should be returned, if it's a
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">function, apply the function to the object and return
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">its value. Otherwise return the property.
</span>    <span style="color: #75766A;">//</span><span style="color: #75766A;">
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">Since JavaScript is synchronous and single-threaded
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">we usually don't have to worry about the value of
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">`$parent' being changed in-between&#185;.
</span>    result = callbalep(property)?  property.apply(object, args)
           : <span style="color: #75766A;">/* </span><span style="color: #75766A;">data property */</span>   property

    <span style="color: #75766A;">// </span><span style="color: #75766A;">Then we remove the `$parent' property we've previously
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">stored, so a subsequent resend performed for this
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">object won't start at the end of the prototype chain.
</span>    <span style="color: #C48DFF;">delete</span> object.$parent

    <span style="color: #75766A;">// </span><span style="color: #75766A;">Finally return whatever result we've got.
</span>    <span style="color: #C48DFF;">return</span> result
}
</pre>



<p>
As you see, this method expects that all the functions called in this
manner to call <code>resend</code> <b>synchronously</b>. This is because we need to
clean the tracking property we've added right after the initial
function returns, and we can only be sure that the other functions in
the chain will have access to that property by requiring that they call
<code>resend</code> synchronously:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">Given a prototype chain A &lt;- B &lt;- C, where the object
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">in the left inherits from the one at right, the
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">following would work nicely:
</span>C.log = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">message</span>) {
    console.log(<span style="color: #A6E32D;">'C:'</span>, message)
}

B.log = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">message</span>) {
    resend(<span style="color: #FA2573;">this</span>, <span style="color: #A6E32D;">'log'</span>, message)
    console.log(<span style="color: #A6E32D;">'B:'</span>, message)
}

A.log = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">message</span>) {
    resend(<span style="color: #FA2573;">this</span>, <span style="color: #A6E32D;">'log'</span>, message)
    console.log(<span style="color: #A6E32D;">'A:'</span>, message)
}

A.log(<span style="color: #A6E32D;">'foo'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; C: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; B: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; A: foo
</span>

<span style="color: #75766A;">// </span><span style="color: #75766A;">But if we made `B.log' asynchronous, then it
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">would not work anymore. Instead, it would have the
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">same problem we've covered earlier, since the tracking
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">property is gone.
</span>B.log = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">message</span>) {
    setTimeout(<span style="color: #C48DFF;">function</span>() {
        <span style="color: #75766A;">// </span><span style="color: #75766A;">`this' has no `$parent' property here anymore
</span>        <span style="color: #75766A;">// </span><span style="color: #75766A;">so the look-up starts at `A', and will always
</span>        <span style="color: #75766A;">// </span><span style="color: #75766A;">resolve to `B'.
</span>        resend(<span style="color: #FA2573;">this</span>, <span style="color: #A6E32D;">'log'</span>, message)
        console.log(<span style="color: #A6E32D;">'B:'</span>, message)
    }.bind(<span style="color: #FA2573;">this</span>), 1000)
}

A.log(<span style="color: #A6E32D;">'foo'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; A: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; B: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; B: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; B: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">( ... )
</span>

<span style="color: #75766A;">// </span><span style="color: #75766A;">The ugly solution is setting the `$parent' directly
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">before the call:
</span>B.log = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">message</span>) {
    <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">parent</span> = <span style="color: #FA2573;">this</span>.$parent
    setTimeout(<span style="color: #C48DFF;">function</span>() {
        <span style="color: #FA2573;">this</span>.$parent = parent
        resend(<span style="color: #FA2573;">this</span>, <span style="color: #A6E32D;">'log'</span>, message)
        console.log(<span style="color: #A6E32D;">'B:'</span>, message)
    }.bind(<span style="color: #FA2573;">this</span>), 1000)
}

A.log(<span style="color: #A6E32D;">'foo'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; A: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; C: foo
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; B: foo
</span></pre>




</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4. Constructors </h2>
<div class="outline-text-2" id="text-4">

<p>Constructor functions are the old pattern for creating objects in
JavaScript, which couple inheritance with initialisation in an
imperative manner.
</p>
<p>
Constructor functions <b>are not</b>, however, a special construct in the
language. Any simple function can be used as a constructor function;
just like <code>this</code>, it all depends on how the function is called.
</p>
<p>
So, what's it about constructor functions, really? Well, every function
object in JavaScript automatically gets a <code>prototype</code> property, that is
a simple object with a <code>constructor</code> property pointing back to the
constructor function. And this object is used to determine the
<code>[⁣[Prototype]⁣]</code> of instances created with that constructor function.
</p>
<p>
The following diagram shows the objects for the constructor function
<code>function Person(first_name, last_name)</code>:
</p>


<p>
<img src="http://dl.dropbox.com/u/4429200/blog/oop-ctor.png"  alt="http://dl.dropbox.com/u/4429200/blog/oop-ctor.png" />
</p>


</div>

<div id="outline-container-4_1" class="outline-3">
<h3 id="sec-4_1">4.1. The <code>new</code> magic </h3>
<div class="outline-text-3" id="text-4_1">

<p>The <code>prototype</code> <i>per se</i> is not a special property, however it gains
special meaning when a constructor function is used in conjunction with
the <code>new</code> statement. As I said before, in this case the <code>prototype</code>
property of the constructor function is used to provide the
<code>[⁣[Prototype]⁣]</code> of the instance.
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">Constructs a new Person
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">Person</span>(<span style="color: #729FCF;">first_name</span>, <span style="color: #729FCF;">last_name</span>) {
    <span style="color: #75766A;">// </span><span style="color: #75766A;">If the function is called with `new', as we expect
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">`this' here will be the freshly created object
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">with the [[Prototype]] set to Person.prototype
</span>    <span style="color: #75766A;">//</span><span style="color: #75766A;">
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">Of course, if someone omits new when calling the
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">function, the usual resolution of `this' &#8212; as
</span>    <span style="color: #75766A;">// </span><span style="color: #75766A;">explained before &#8212; will take place.
</span>    <span style="color: #FA2573;">this</span>.first_name = first_name
    <span style="color: #FA2573;">this</span>.last_name  = last_name
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person
</span>Person.<span style="color: #FA2573;">prototype</span>.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Harro, '</span> + person + <span style="color: #A6E32D;">'.'</span> 
}

<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">person</span> = <span style="color: #C48DFF;">new</span> <span style="color: #FC951E;">Person</span>(<span style="color: #A6E32D;">'Mikhail'</span>, <span style="color: #A6E32D;">'Wei&#223;'</span>)


<span style="color: #75766A;">// </span><span style="color: #75766A;">We could de-sugar the constructor pattern in the following
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Taking into account that `Person' here means the `prototype'
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">property of the `Person' constructor.
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">Person</span> = Object.create(Object.<span style="color: #FA2573;">prototype</span>)

<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person
</span>Person.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Harro, '</span> + person + <span style="color: #A6E32D;">'.'</span> 
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Here's what the constructor does when called with `new'
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">person</span> = Object.create(Person)
person.first_name = <span style="color: #A6E32D;">'Mikhail'</span>
person.last_name  = <span style="color: #A6E32D;">'Wei&#223;'</span>
</pre>



<p>
When a function is called with the <code>new</code> statement, the following magic
happens:
</p>
<ol>
<li>
Create a fresh <code>Object</code>, inheriting from <code>Object.prototype</code>, say <code>{ }</code>

</li>
<li>
Set the <code>[⁣[Prototype]⁣]</code> internal property of the new object to point
to the constructor's <code>prototype</code> property, so it inherits those
behaviours.

</li>
<li>
Call the constructor in the context of this fresh object, such that
<code>this</code> inside the constructor will be the fresh object, and pass any
parameters given to the function.

</li>
<li>
If the function returns an <code>Object</code>, make that be the return value of
the function.

</li>
<li>
Otherwise, return the fresh object.
</li>
</ol>


<p>
This means that the resulting value of calling a <code>function</code> with the
<code>new</code> operator is not necessarily the object that was created. A
function is free to return any other <code>Object</code> value as it sees fit. This
is an interesting and — to a certain extent — powerful behaviour, but
also a confusing one for many newcomers:
</p>



<pre class="src src-js"><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">Foo</span>() {
    <span style="color: #FA2573;">this</span>.foo = <span style="color: #A6E32D;">'bar'</span>
}

<span style="color: #C48DFF;">new</span> <span style="color: #FC951E;">Foo</span>()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; { foo: 'bar' }
</span>

<span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">Foo</span>() {
    <span style="color: #FA2573;">this</span>.foo = <span style="color: #A6E32D;">'bar'</span>
    <span style="color: #C48DFF;">return</span> Foo
}

<span style="color: #C48DFF;">new</span> <span style="color: #FC951E;">Foo</span>()
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [Function: Foo]
</span></pre>




</div>

</div>

<div id="outline-container-4_2" class="outline-3">
<h3 id="sec-4_2">Inheritance with constructors </h3>
<div class="outline-text-3" id="text-4_2">

<p>We've covered inheritance with plain objects through <code>Object.create</code>,
inheritance with constructors follow quite naturally from there, the
difference being that instead of the main actor being the target of the
inheritance (the constructor function, in this case), the <code>prototype</code>
property is:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">new Person (first_name:String, last_name:String)
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Initialises a Person object
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">Person</span>(<span style="color: #729FCF;">first_name</span>, <span style="color: #729FCF;">last_name</span>) {
    <span style="color: #FA2573;">this</span>.first_name = first_name
    <span style="color: #FA2573;">this</span>.last_name  = last_name
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Defines the `name' getter/setter
</span>Object.defineProperty(Person.<span style="color: #FA2573;">prototype</span>, <span style="color: #A6E32D;">'name'</span>, { get: get_full_name
                                                , set: set_full_name
                                                , writable:     <span style="color: #FA2573;">true</span>
                                                , configurable: <span style="color: #FA2573;">true</span>
                                                , enumerable:   <span style="color: #FA2573;">true</span> })

<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Greets the given person
</span>Person.<span style="color: #FA2573;">prototype</span>.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': Hello, '</span> + (person || <span style="color: #A6E32D;">'you'</span>)
}


<span style="color: #75766A;">// </span><span style="color: #75766A;">new Mikhail (age:Number, gender:String)
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">Mikhail</span>(<span style="color: #729FCF;">age</span>, <span style="color: #729FCF;">gender</span>) {
    resend(<span style="color: #FA2573;">this</span>, <span style="color: #A6E32D;">'constructor'</span>, <span style="color: #A6E32D;">'Mikhail'</span>, <span style="color: #A6E32D;">'Wei&#223;'</span>)
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Inherits the properties from Person.prototype
</span>Mikhail.<span style="color: #FA2573;">prototype</span> = Object.create(Person.<span style="color: #FA2573;">prototype</span>)

<span style="color: #75766A;">// </span><span style="color: #75766A;">Resets the `constructor' property of the prototype object
</span>Mikhail.<span style="color: #FA2573;">prototype</span>.constructor = Mikhail

<span style="color: #75766A;">// </span><span style="color: #75766A;">(person:String) &#8594; String
</span>Mikhail.<span style="color: #FA2573;">prototype</span>.greet = <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">person</span>) {
    <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.name + <span style="color: #A6E32D;">': \'sup, '</span> + (person || <span style="color: #A6E32D;">'dude'</span>)
}


<span style="color: #75766A;">// </span><span style="color: #75766A;">Instances are created with the `new' operator, as previously
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">discussed:
</span><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = <span style="color: #C48DFF;">new</span> <span style="color: #FC951E;">Mikhail</span>(19, <span style="color: #A6E32D;">'Male'</span>)
mikhail.greet(<span style="color: #A6E32D;">'Kristin'</span>)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'Mikhail Wei&#223;: \'sup, Kristin'
</span></pre>




</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5. Considerations and compatibility </h2>
<div class="outline-text-2" id="text-5">

<p>The functions and concepts presented up until now assumed that the code
would be running in an ECMAScript 5 environment, since the new additions
make prototypical inheritance more natural, without the initialisation
and inheritance coupling provided by constructor functions.
</p>
<p>
However, obviously this means that code using these functions will not
work everywhere. <a href="http://twitter.com/kangax">@kangax</a> has a most awesome <a href="http://kangax.github.com/es5-compat-table/">compatibility table</a> for the
implementations that follow ECMAScript 5.
</p>
<p>
This section provides fallbacks to some of the functionality, and point to
libraries that implement these fallbacks so you don't get to reinvent
the wheel. Note that this section only exists to highlight how the
functionality works, and how those behaviours could be reproduced in
legacy code, it's not meant to provide ready-to-use fallbacks. Use
libraries for that :3
</p>


</div>

<div id="outline-container-5_1" class="outline-3">
<h3 id="sec-5_1">5.1. Creating objects </h3>
<div class="outline-text-3" id="text-5_1">

<p>In ECMAScript 5 we have got <code>Object.create</code> to handle inheritance, but
there's also constructor functions, which can be used to set the
<code>[⁣[Prototype]⁣]</code> link for the constructed object — which is what we're
interested about.
</p>
<p>
A <code>clone</code> function could be defined such that it would create a new
object based on the given prototype:
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(proto:Object) &#8594; Object
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Constructs an object and sets the [[Prototype]] to `proto'.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">clone</span>(<span style="color: #729FCF;">proto</span>) {
    <span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">Dummy</span>() { }

    Dummy.<span style="color: #FA2573;">prototype</span>             = proto
    Dummy.<span style="color: #FA2573;">prototype</span>.constructor = Dummy

    <span style="color: #C48DFF;">return</span> <span style="color: #C48DFF;">new</span> <span style="color: #FC951E;">Dummy</span>()
}

<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">mikhail</span> = clone(person)
<span style="color: #75766A;">// </span><span style="color: #75766A;">Equivalent to `var mikhail = Object.create(person)'
</span></pre>




</div>

</div>

<div id="outline-container-5_2" class="outline-3">
<h3 id="sec-5_2">5.2. Defining properties </h3>
<div class="outline-text-3" id="text-5_2">

<p><code>Object.defineProperty</code> and it's batch cousin <code>Object.defineProperties</code>
are also new additions, and they allow properties to be defined with
internal tags, like <code>writable</code>, <code>configurable</code> and <code>enumerable</code>. It's
not possible to get this behaviour in the older versions of the
language.
</p>
<p>
All properties defined will inevitable have <code>writable</code>, <code>configurable</code>
and <code>enumerable</code> set to true, which is usually not really that much of a
problem — still, not really compatible with full ES5 code.
</p>
<p>
In regards of getters and setters, they are supported to a certain
extent with non-standard syntax — the <code>__defineGetter__</code> and
<code>__defineSetter__</code> methods, — but are also not available
everywhere. Most notably, such methods have never been present in IE.
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(target:Object, key:String, descriptor:Object) &#8594; Object
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Defines a property in the target object.
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Getters and Setters are handled through the fallback
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">calls, whereas values are set directly. Tags are
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">ignored.
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">defineProperty</span>(<span style="color: #729FCF;">target</span>, <span style="color: #729FCF;">key</span>, <span style="color: #729FCF;">descriptor</span>) {
    <span style="color: #C48DFF;">if</span> (descriptor.value)
        target[key] = descriptor.value
    <span style="color: #C48DFF;">else</span> {
        descriptor.get &amp;&amp; target.__defineGetter__(key, descriptor.get)
        descriptor.set &amp;&amp; target.__defineSetter__(key, descriptor.set) }

    <span style="color: #C48DFF;">return</span> target
}


<span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">x</span> = { }
defineProperty(x, <span style="color: #A6E32D;">'foo'</span>, { value: <span style="color: #A6E32D;">'bar'</span> })
defineProperty(x, <span style="color: #A6E32D;">'bar'</span>, { get: <span style="color: #C48DFF;">function</span>() { <span style="color: #C48DFF;">return</span> <span style="color: #FA2573;">this</span>.foo }
                         , set: <span style="color: #C48DFF;">function</span>(<span style="color: #729FCF;">v</span>){ <span style="color: #FA2573;">this</span>.foo = v    }})

x.foo
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'bar'
</span>
x.bar
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'bar'
</span>
x.bar = <span style="color: #A6E32D;">'foo'</span>
x.foo
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'foo'
</span>
x.bar
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; 'foo' 
</span></pre>





</div>

</div>

<div id="outline-container-5_3" class="outline-3">
<h3 id="sec-5_3">5.3. Listing properties </h3>
<div class="outline-text-3" id="text-5_3">

<p>We have seen how it's possible to list the properties of an object with
<code>Object.getOwnPropertyNames</code>, and list only the enumerable properties
through <code>Object.keys</code>. Well, prior to ECMAScript 5, listing the
enumerable properties is the only thing one can do.
</p>
<p>
This is achieved through the <code>for..in</code> statement, which iterates through
all the enumerable properties of an object, either directly set in the
object, or in the prototype chain. <code>Object.prototype.hasOwnProperty</code> may
be used to filter the properties to include only the ones set directly
in the object.
</p>



<pre class="src src-js"><span style="color: #75766A;">// </span><span style="color: #75766A;">(object:Object) &#8594; Array
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Lists all the own enumerable properties of an object
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">keys</span>(<span style="color: #729FCF;">object</span>) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">result</span>, <span style="color: #729FCF;">key</span>
    result = []
    <span style="color: #C48DFF;">for</span> (key <span style="color: #C48DFF;">in</span> object)
        <span style="color: #C48DFF;">if</span> (object.hasOwnProperty(key))  result.push(key)

    <span style="color: #C48DFF;">return</span> result
}

<span style="color: #75766A;">// </span><span style="color: #75766A;">Taking the mikhail object whose [[Prototype]] is person...
</span>keys(mikhail)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'first_name', 'last_name', 'age', 'gender' ]
</span>
keys(person)
<span style="color: #75766A;">// </span><span style="color: #75766A;">=&gt; [ 'greet', 'name' ]
</span></pre>




</div>

</div>

<div id="outline-container-5_4" class="outline-3">
<h3 id="sec-5_4">5.4. Bound methods </h3>
<div class="outline-text-3" id="text-5_4">

<p>Bound methods in JavaScript do much more than just assert the value of
<code>this</code> inside a function, they can also be used for partial function
applications and behave slightly different when called as a
constructor. For this, we'll just focus on the first two.
</p>
<p>
Basically, when calling the <code>bind</code> method of a function, we're creating
a new function object that has a defined <code>thisObject</code> and perhaps a
defined initial list of arguments. This can be just as well achieved
with a closure to store the given state, and a explicit function
application, through the <code>apply</code> method.
</p>



<pre class="src src-js"><span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">slice</span> = [].slice

<span style="color: #75766A;">// </span><span style="color: #75766A;">(fn:Function, bound_this:Object, args...) &#8594; Function
</span><span style="color: #75766A;">//  </span><span style="color: #75766A;">--&gt; (args...) &#8594; *mixed*
</span><span style="color: #75766A;">// </span><span style="color: #75766A;">Creates a bound method from the function `fn'
</span><span style="color: #C48DFF;">function</span> <span style="color: #67D9F0;">bind</span>(<span style="color: #729FCF;">fn</span>, <span style="color: #729FCF;">bound_this</span>) { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">bound_args</span>
    bound_args = slice.call(<span style="color: #FA2573;">arguments</span>, 2)
    <span style="color: #C48DFF;">return</span> <span style="color: #C48DFF;">function</span>() { <span style="color: #C48DFF;">var</span> <span style="color: #729FCF;">args</span>
        args = bound_args.concat(slice.call(<span style="color: #FA2573;">arguments</span>))
        <span style="color: #C48DFF;">return</span> fn.apply(bound_this, args) }
}
</pre>




</div>

</div>

<div id="outline-container-5_5" class="outline-3">
<h3 id="sec-5_5">5.5. Libraries that provide fallbacks </h3>
<div class="outline-text-3" id="text-5_5">


<p>
<a href="https://github.com/kriskowal/es5-shim">ES5-shim</a> attempts to implement fallbacks for ECMAScript 5 functionality
that can be done in pure JavaScript, whilst adding minimal support
for the other ones. It's important to note, however, that the
fallbacks are intended to provide equivalent functionality that is
close to the ones defined in the specs, it's not guaranteed that they
will work exactly the same.
</p>
<p>
To quote the <code>README</code>:
</p>
<blockquote>

<p>"As closely as possible to ES5" is not very close. Many of these shims
are intended only to all ow code to be written to ES5 without causing
run-time errors in older engines. In many cases, this means that
these shims cause many ES5 methods to silently fail. Decide carefully
whether this is what you want. 
</p>
</blockquote>



</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">6. Wrapping it up </h2>
<div class="outline-text-2" id="text-6">

<p>The object orientation model chosen for JavaScript is definitely one of
the things that makes the language expressive and powerful, however the
really poor semantics from the before-ES5 age quite killed all the fun
about it.
</p>
<p>
With ECMAScript 5, we have got better ways to deal with objects and
inheritance, but most of the API is pretty verbose and awkward to use
out of the box, so abstracting them is the only sane way of exploring
all the power of the first-class inheritance model provided by the
language.
</p>
<p>
Once you dwell on the depths of JavaScript's prototypical object
orientation, however, you will find it lacking on aspects that would
otherwise seem like the obvious thing to do — like multiple inheritance
and message resending, but also basic features like an easier object
extension functionality.
</p>
<p>
Luckily most of these issues manage to have a solution, albeit not
necessarily a satisfactory one in some cases — i.e.: manual
mixins. Being able to reproduce semantics that are not provided straight
away on the language by patterns leveraging the built-in constructs is
an important part of the language, and this all is made easier because
of the way functions are treated in JavaScript.
</p>

</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">7. Things worth reading up next </h2>
<div class="outline-text-2" id="text-7">


<br>

<dl>
<dt><a href="http://www.aminutewithbrendan.com/pages/20110216">Brendan Eich's "Prototypical vs Closure" rant</a></dt><dd>

<p>
Although not really a reading, this particular podcast from Brendan
Eich is a must listen for anyone working with object oriented
JavaScript. it delves on the performance of engines in regards of
object construction, highlighting how the prototypical pattern stands
against the <a href="http://yuiblog.com/blog/2007/06/12/module-pattern/">Closure pattern</a>, and discussing the specifics of how
browsers handle prototypical code so they run <b>fast</b>.
</p>
</dd>
</dl>

<dl>
<dt><a href="http://labs.oracle.com/self/papers/organizing-programs.html">Organizing Programs Without Classes</a> <i>(paper)</i></dt><dd>

<p>
Albeit not specific to JavaScript, this white-paper dwells on how the
structuring of programs differ from the classical object orientation
approach to the prototypical take on the subject. It provides lots of
<a href="http://selflanguage.org/">Self</a> code to go with it, but they are more or less easily translated
to JavaScript code.
</p></dd>
</dl>





</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> : Some implementations have magical names, like <code>__proto__</code>, which
may yield undesired and unwanted results when set. For example,
<code>__proto__</code> property is used to define the parent of an object
in some implementations. As such, you wouldn't be able to set a
string or number to that.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> Some engines <b>do</b> expose the <code>[⁣[Prototype]⁣]</code> slot, usually
through a property like <code>__proto__</code>, however no such thing is
described in the specifications for the language, so it's
recommended that you avoid using it, unless you're well aware
that all platforms you code must run on will have such means of
setting the <code>[⁣[Prototype]⁣]</code> object directly.
</p>
</div>
</div>
