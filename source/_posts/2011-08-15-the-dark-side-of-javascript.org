#+STARTUP: showall hidestars indent
#+OPTIONS: toc:nil
#+BEGIN_HTML
---
layout: post
title:  The Dark-Side of JavaScript
snip:   On making functional JavaScript deliciously sweet.
---
#+END_HTML


[[http://github.com/killdream/black][Black]] is an extension to JavaScript's standard objects, providing
missing functionality, a few aliases and making using generic functions
sweeter.

It supports both functional style:

#+begin_src javascript
  black.unpack_all(['utils', 'generic'])
  each(map(filter(links, selectedp)
          ,text)
      ,display)
#+end_src
        
And Object Oriented style:

#+begin_src javascript
  black.unpack_all(['own'])
  black.list.to_array(links).filter(selectedp)
                            .map(text)
                            .each(display)
#+end_src

And it can use either the global scope or patch the native object's
prototype directly, if *you* decide to do so.

If you're on Node.js, you can just install it from npm:

#+begin_src shell-script
  $ npm install black
#+end_src
    
Otherwise, clone the github repository and follow the
[[http://killdream.github.com/black/docs/deploy/overview/installing.html][installation instructions]].

#+begin_src shell-script
  $ git clone htp://github.com/killdream/black.git
    
  # Or if you use hg-git, like me:
  $ hg clone http://github.com/killdream/black.git
#+end_src


* The issues

Black didn't just sprung out of nowhere, it came into existence to fix
several issues I've had while writing JavaScript code. 


** Lack of functionality and generic sugar

The main issue was that I often had to write the same functions over and over
again, because the standard library didn't provide them.

That goes from the simple object handling, that is, merging two objects, from
sequence handling, which I do use *a lot*. On this release, I've tried to
include the features I miss the most, for numbers, functions, objects and
sequences.

Yes, *sequences*, not *Arrays*. Since JavaScript is weakly-typed to the very
core, mostly functionality is intentionally generic. However, using those
generic functions on non-arrays is usually a huge. pain. in. the. ass:

#+begin_src javascript
  var seq = {0: 1, 1: 2, 2: 3, length: 3}
  Array.prototype.map.call(seq, function(x){ return x + 1 })
  // => [2, 3, 4]
#+end_src
    
That unnecessary verbosity really annoys me. Other thing that does so is the
inconsistency in own and generic methods. You can't just have
~Array.slice(sequence)~, even though the method is supposed to be generic, you
need to apply an Array's own method to another object type if you need it. For
me, it just makes no sense.


** Verbosity and hatefulCamelCaseIsHateful

The second major issue I have is the naming convention used in
JavaScript. Sorry guys, but camelCase sucks way too much to be taken
seriously. And on top of that, lots of functionality have unnecessary and
overly verbose names.

Note that when I say /verbose/ I don't necessarily mean *long*. There's a huge
difference here. Verbosity is the unnecessary extension of a name just for the
sake of having a long name. Descriptive and concise names are your friends when
you actually want to read a piece of code.


** Aliasing hell

One thing I noticed a lot lately, is that all my JavaScript files were
starting with the following:

#+begin_src javascript
  var map    = [].map
    , each   = [].each
    , some   = [].some
    , every  = [].every
    , reduce = [].reduce
    , filter = [].filter
    , slice  = [].slice
    , hasp   = {}.hasOwnProperty
    , ( ... )
#+end_src

Things were coming to a point that I had written a template in [[http://code.google.com/p/yasnippet][Yasnippet]] to
include all those lines for me. But well, even so, it was still quite
unwielding and I still raged every time I saw that shitload of aliases at the
start of every file (things only got worse when the file used external
libraries, btw).

If only current ECMAScript had [[https://developer.mozilla.org/En/New_in_JavaScript_1.7#Destructuring_assignment_(Merge_into_own_page.2fsection)][destructuring assignment]] support, things
wouldn't be as bad:

#+begin_src javascript
  var {map, each, reduce, filter} = Array.prototype
#+end_src
    
Which is not that much different from Python's:

#+begin_src python
  from module import x, y, z
#+end_src
    
Except you can import anything you want from any object. Having written some
code for SpiderMonkey-only projects before, I can say that JavaScript 1.7
introduces quite a lot of awesomeness I missed in the language for a long time
(and still miss...)


* What Black provides

** Extensions

The main point of Black is to include extensions for working with the
standard objects. Most of the extensions are for working with sequences,
and objects. Extensions are logically divided in modules, and can be
used separately.

- type ::
  Provides type, interface and functionality testing.

- obj ::
  Handles objects as sets of key/values. This includes extracting
  lists of keys and values, cherry-picking and transforming them.

- list ::
  Handles iteration and manipulation of sequence's structure and
  items.
    
- str ::
  Provides generic aliases for built-in utilities and sugar for
  JS/CSS interop.
    
- num ::
  Provides a few mathematical functions for boundary handling and
  padding.
    
- fn ::
  Provides a few functional utilities. Currently not much useful.


** Sane API naming

Black's API uses a naming convention derived from Python and Lisp. Words
are written in all lower-case and separated by underscores. Names are
kept concise and descriptive.

From Common Lisp, it uses the ~p~-suffix naming convention for predicate
functions (like ~nullp~ for ~null?~ or ~isNull~). And ~n~-prefix for
destructive functions when a pure alternative exists.

For functions that construct objects, a ~make_~ prefix is used.


** Patching

The actual thing about Black, though, is how it handles the aliasing
hell issue. The ~core~ module provides unpacker functions that copies
properties from an Object to another one. Modules decide which
functionality they want to export and where they want it exported by
default.

The unpackers separate functionality into ~utils~, which are exported to
the global object; ~generic~, which are exported directly into the
constructor function; and ~own~, which are exported into the
~[⁣[Prototype]⁣]~.

This patching is carried by two functions, the /just-do-the-right-thing(tm)/
one, ~unpack_all~, which will follow the defaults the modules have provided:

#+begin_src javascript
  black.unpack_all(['utils', 'generic', 'own'])
  var factor = 2
  first(range(1, 10).filter(function(x){
      return x > 3 * factor }))
  // => 7
#+end_src
    
And the fine-tuned one, if you want control over where you want your
stuff, ~unpack~:

#+begin_src javascript
  var numbers = [1, 2, 3, 4, 5]
  black.unpack(['own'], null              // global target
                      , null              // generic target
                      , Array.prototype   // own
                      , black.list )      // source
    
  function squared(x){ return x * x      }
  function evenp(x)  { return x % 2 == 0 }
  numbers.map(squared).filter(evenp).first()
  // => 4
#+end_src

* Wrapping it up

This is still an early release of the library, it's usable, but not
thoroughly tested (and all tests have been done only on
Node.js). Though, it has some documentation and examples, and most
functionality I wanted for now, so I'm just making an early release.

I'm planning checking for set difference in the unpackers to avoid
silently writing existing functionality, associative sequence handling,
and other stuff, so well, still lots of work to do :3
