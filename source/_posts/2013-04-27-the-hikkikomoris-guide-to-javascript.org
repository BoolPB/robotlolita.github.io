#+STARTUP: showall hidestars indent
#+BEGIN_HTML
---
layout: post
title:  The Hikikomori's Guide to JavaScript
snip:   How to write simple, useful and composable JavaScript applications.
---
#+END_HTML

#+BEGIN_QUOTE
  “The Answer to the Great Question... Of Life, the Universe and
  Everything... Is... Forty-two,' said Deep Thought, with infinite
  majesty and calm.”

  — Douglas Adams in The Hitchhiker's Guide to the Galaxy.
#+END_QUOTE

Why am I quoting Douglas Adam's most awesome book? Why am I using a
wordplay on its title on my blog post title? Why are JavaScript's
modules such a mess? How do brains work? Well, my dearest basement
dwellers, I am afraid I do not have all the answers, but none the less I
shall try to provide some tips on writing useful, simple and composable
applications for the Great Good™ of the JavaScript community here.

Here's a TL;DR:

  - Start with an API to manipulate your data, not with an Application.

  - Extract the most basic, orthogonal concepts, and provide primitives
    to encode them.

  - Provide “glue” code to compose concepts together and create big
    things.

  - Work with structured data.

  - Write the actual application using your API.


* Introduction

There was a time when no one knew how to write JavaScript, but those
times are long since gone. People know how to write JavaScript now
(some), and that's good!!1ELEVEN! Unfortunately, there's still a large
portion of people who don't know how to write applications[fn:1].

As a result of this, you often end up with applications that do too
much, or applications that do too little. But the worst problem of all
is when you end up with applications that you can only use through some
interface of sorts, and can't easily manipulate the stuff you're
interested in with different things. Mind you, programmatic extensions
matter a lot!

Thus, in this blog post I'll try to provide a few hints on how to
achieve small, composable and extensible applications. Stick with me!


* Start with an API

Don't start with an Application, start with the API. This might seem
weird, but it actually makes a lot of sense, because the API defines how
other people can interact with the data your application
manipulates. But hey, why should we leave that as “other people”? Let me
rephrase:

#+BEGIN_QUOTE
  The API defines how you (and other people) can interact with the data
  in your application.
#+END_QUOTE

My usual design approach is to examine the inputs and outputs of the
application, and then design an API that handles such data. Later I'll
stack the user experience and the “glue” code on top of such API to form
an actual application.

This fits nicely with the "One Module Does One Thing" approach because
then the API defines which kind of data you're dealing with, and all the
meaningful transformations you can apply to such data. Transformations
in turn do one thing, and might be grouped logically.

For example, let's say we want to write an application to display Tweets
to the user. First and foremost, we examine the inputs and outputs, and
draft a types to encode the data in our application (I'm using a type
notation inspired by Haskell, but this should be nonetheless pretty
straightforward):

#+BEGIN_SRC haskell
  -- | A TwitterTweet is something Twitter gives us (the input)
  -- (note that this is a stripped down version)
  type TwitterTweet
    favorited     :: Boolean
    retweeted     :: Boolean
    retweet_count :: Number

    created_at :: String  --^ Serialised Date
    source     :: String
    user       :: User
    id_str     :: String

    in_reply_to_user_id_str   :: String
    in_reply_to_status_id_str :: String
    in_reply_to_screen_name   :: String

    entities   :: { "urls"          :: [Entity]
                  , "hashtags"      :: [Entity]
                  , "user_mentions" :: [Entity]
                  }

    text :: String    
#+END_SRC

So, the data Twitter gives us is quite a mess, and it'd be really
difficult to manipulate that kind of data in our application. We can do
better, so let's define a better type to encode a Tweet:

#+BEGIN_SRC haskell
  type User
    name :: String --^ The users' screen name
    id   :: String --^ Twitter's user ID
    
  type Entity
    url          :: String
    expandedUrl  :: String
    displayUrl   :: String
    indices      :: (Number, Number)


  type Text
    plain    :: String
    entities :: { "urls"          :: [Entity]
                , "hashtags"      :: [Entity]
                , "user_mentions" :: [Entity]
                }

  type Tweet
    id            :: String --^ Unique identifier for this tweet
    user          :: User   --^ The user that tweeted this
    inReplyTo     :: Tweet
    source        :: String --^ Which application was used to compose this
    date          :: Date   --^ When this tweet was crafted
    favourited    :: Boolean
    retweeted     :: Boolean
    retweetCount  :: Number
    text          :: Text
#+END_SRC

So, now =User= and =Text= are separate types, this is because they make
sense outside of the context of a =Tweet= and we might want to
manipulate them separately. There's no reason to provide a complected
type to a function that only needs to know the name of a user, for
example.

Once we're done with the types our application needs to manipulate, we
can draft an API that provides the primitives to manipulate these
types, given the operations we'll be applying to them and the output.

#+BEGIN_SRC haskell
  -- * Type conversions

  --| We need to convert from Twitter format to ours
  normaliseTweet :: TwitterTweet -> Tweet

  --| Convert Twitter Date serialisation to actual DateTime
  parseDate :: String -> Date

  --| Extract User that composed the tweet
  twittedBy :: TwitterText -> User

  --| Extract reply information
  repliedToUser :: TwitterText -> User
  repliedToTweet :: TwitterText -> Tweet

  --| Extract the Text
  textFor :: TwitterText -> Text


  -- * Display transformations

  --| We want to display a Tweet as HTML
  renderTweet :: Tweet -> HTML

  --| We want to display a Text as HTML
  textToHTML :: Text -> HTML

  --| We want to know the relative time since the tweet
  fromNow :: Date -> String

  --| We want to display a link to a User
  linkToUser :: User -> HTML

  --| We also want to display a link to a Tweet
  linkToTweet :: Tweet -> HTML
#+END_SRC


* Provide “glue” code to compose concepts

Compositionality is a big thing. Compositionality is what you want in a
big application. Compositionality is what will save your bacon when you
have to actually maintain all the shit you've written. This is one of
the reasons we don't put them in the first API draft, we want to get the
primitives right first, and make sure they don't overlap!

Back to our Twitter example, when you retrieve data from Twitter, you
usually get a List of tweets. Notice that nothing in the previous API
allows you to take a list of Tweets and spits back a list of HTMLs, but
it can take a single tweet and spit back a single HTML. We also have
baked right into the standard library a function that takes a List of
things, a function that transforms a thing A in thing B, and returns a
list of things B. Well, this is enough to derive our transformation for
lists of Tweets:

#+BEGIN_SRC js
  // Renders a list of Tweets
  // renderTweetList :: [Tweet] -> [HTML]
  function renderTweetList(tweets) {
    return tweets.map(renderTweet)
  }

  // Or we can use a better version of Map (if you know functional
  // programming) 
  var map = curry(2, Function.call.bind([].map))
  var renderTweetList = map(renderTweet)


  // -- An aside: ------------------------------------------------------

  // If you don't know what `curry` is, well. A minimal explanation
  // would be that functions in JavaScript actually takes a List of
  // arguments. You should think about:
  function add(a, b) { return a + b }

  // As being actually:
  function add(arguments){ return arguments[0] + arguments[1] }
  
  // And when you're calling it as: add(1, 2) you're actually saying
  // add([1, 2]).

  // Currying takes a different route. Functions takes only one
  // argument:
  function itself(a) { return a }

  // If you need to create a function that takes more than one argument,
  // you use closures:
  function add(a){ return to(b) { return a + b }}

  // And when you're calling it as: add(1, 2) you're actually saying
  // add(1)(2).

  // You can see an implementation here:
  // https://github.com/killdream/athena/blob/master/src/higher-order.ls#L56-L81
#+END_SRC



But this doesn't display anything in the screen yet, mostly because
that's not the job of renderTweetList — it already does everything it
needs to do. A thing that displays tweets on the screen should be
something that takes an HTML a container and adds that HTML to the
container:

#+BEGIN_SRC js
  // addTo :: HTML, HTML -> HTML
  function addTo(container, html) {
    $(container).append(html)
    return container
  }
#+END_SRC

Now we can derive a simple function that will take a list of HTML
things, and add them to a container (the glue):

#+BEGIN_SRC js
  // addAllTo :: HTML, [HTML] -> HTML
  function addAllTo(container, htmls) {
    htmls.map(function(html){ addTo(container) })
    return container
  }

  // Or, we can go use our Curry friend and make it better-er
  var addTo = curry(2, addTo)
  var addAllTo = curry(2, function(container, htmls) {
    htmls.map(addTo(container))
    return container
  })
#+END_SRC
 

[fn:1]: I am, of course, referring to my own notion of How Applications
        Should Be Written™, which might be fairly arbitrary.
