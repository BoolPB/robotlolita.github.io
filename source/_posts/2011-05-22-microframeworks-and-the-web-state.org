#+STARTUP: showall hidestars indent
#+LINK: twitter http://twitter.com/
#+LINK: mdn     https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/
#+BEGIN_HTML
---
layout: post
title:  Microframeworks and the state of the web
snip:   An in-depth look at both sides of the same coin.
---
#+END_HTML


Micro-"/frameworks/"[fn:1] have been quite a hot topic lately on the
JavaScript community. And by /hot/, I mean that it has lead to some
pretty "heated" discussion (either good ones and "bad" ones), and some
[[http://allyoucanleet.com/2011/05/09/microlibs-the-fud-challenge/][pretty interesting]] [[http://tomdale.net/2011/05/an-uphill-battle/][replies]].

But what's all this fuzz about? Well, the /microlibs/ introduce a shift
from the monolithic libraries (think [[http://jquery.com/][jQuery]], [[http://www.prototypejs.org/][Prototype]], etc), to
self-contained and "modular" ones.

In this post I'll try to explain what's good and bad about either approaches,
delve a little on modular design and sum up what I think that's wrong with most
JS libs, and where we should go from here.


*Note:*
#+BEGIN_QUOTE
I'm going to use *microlibs* thorough this article to refer to what
people call micro-"frameworks"[fn:1] as I think the name fits better
what they actually are.
#+END_QUOTE

* What's wrong with JS frameworks

So you have a new web app to develop, and you're looking for some
building blocks because you don't want to write everything from the
scratch?

Toughest luck, my dear.

Welcome to the "Reproducing desktop's UI toolkit mess in the JavaScript
world" show, only worse. A thousand times worse!


** 1. Feature bloat

If you take [[http://jquery.com/][jQuery]], which weights around 230kb (31kb minified AND
gzipped), you will get all the following goodies out of the box:

 - CSS Selector engine
 - DOM abstraction API
 - Deferreds
 - Ajax/XMLHttpRequest abstractions
 - JSONP
 - CSS helpers
 - Animation/Effects
 - Event abstraction
 - Some other small utilities to fill in some standard lib "gaps"
 - Lots of cross-browser hacks

That is, obviously, overwhelming. People usually don't use all of the
features the library provide, and the overhead of this "dead code" feels
even larger because you have tons of them.

The problems are also solved at a reduced scope, as you'd otherwise have
an unwielding codebase/filesize. For example, the effects included in
jQuery only cover the most basic use-cases, whereas other features have
a lot more of coverage — DOM abstraction.


** 2. Large filesize

Having more code equals having a larger filesize, which is a
problem in web apps because you'll be sending a lot of dead code over
the wire.

This is bad from both the end-user's perspective: pages will take more
time to load, and this hurts a good user experience. No one likes
waiting 2 minutes to see a web site.

And from an efficiency's perspective. You should be very worried about
sending lots of code that will never be used, sir. Seriously.


** 3. Higher learning curve

As you have more features, you'll take longer to master them. This is
not really that much of a problem on the end-user dev, because you would
probably have to learn the same amount of things by stacking lots of
small libraries together.

However, the thing is that it'll take far more time to understand all
the implications of the source code to extend it. Whereas with a simpler
and focused library, it would be quite straight forward.


** 4. Framework-centric code

But all these minor annoyances aside, there's one big issue with the way
most JavaScript frameworks are designed: they encourage you to write
Framework-centric code.

Want to write a date handling library? You should tie the core workings
to the jQuery's DOM manipulation functions. What about a library that
abstracts browser storage? TIE IT TO THE FRAMEWORK'S DOM HANDLING LIKE A
BOSS!

Mind you, the browser is not just about the DOM, or a framework. Writing
framework-centric code when your library does NOT extend on the problem
the framework is trying to solve is a silly thing.

The community can't benefit from your contribution as a whole because
they can't include the DOM framework you're using in their
projects. Either because doubling the overhead with code that solves the
same problem should warrant you a death sentence, and because mixing DOM
libraries may break everything in some cases (Prototype + jQuery, for
example).


* Microlibs to the rescue!

As a response to that, wild microlibs appeared. The main design goal of
these libraries is to focus on doing just a single thing — and doing
that well, while also "doing the simplest thing that could possibly
work".

As such, there's little to no overlap on the features offered from one
microlib to another (given they don't try to solve the same problem, of
course) and you get only what you really need. No more, no less.

In fact, microlibs would fit the [[http://en.wikipedia.org/wiki/Unix_philosophy][Unix philosophy]] quite well (the
text streams aside, usually):

#+BEGIN_QUOTE
Write programs that do one thing and do it well. Write programs to
work together. Write programs to handle text streams, because that is
a universal interface.
#+END_QUOTE

* ...but microlibs are broken too

Reality is a bit harsh, though. There are a few problems with the
*current state* of microlibs, both because they're pretty new and
because somehow this whole size-limit thing has gotten quite messed up.

Some of these problems are quite a show stopper. 


** 1. Lack of documentation

Documentation is good and shouldn't be overlooked. If you want people to
use your code, you should tell them how they should use it. No, dumping
a weird API reference on a ~README~ file won't cut it. Random words
scrawled over the source won't either.

I'm talking about good documentation on the library btw, not just some
API reference. And most microlibs I know (including my [[http://github.com/killdream/ekho][Ekho]] lib)
have no examples, no use cases, no how to get started, no anything!

But there are worse cases (imo). All [[twitter:ded][@ded]]'s libraries have almost
no comments on the source code, and rely rather on dumping a little of
introductory text on an obscure ~README.md~ file.

Mind you, I want to know what are the purposes and implications of using
some function if I'm going to extend the library. I don't want to shoot
myself on the foot by accidentally calling a function that happens to
have side-effects which are not apparent from reading the function
alone.


** 2. Lack of tests

Some libraries do have a small amount of test cases, but as
[[twitter:jDalton][@jDalton]] showed on his [[http://allyoucanleet.com/2011/05/09/microlibs-the-fud-challenge/][screen cast]], some don't really
have that good of a coverage.

Some libraries ([[http://github.com/killdream/ekho][Ekho]]) have absolutely NO unit tests, which is something you
should find outrageous[fn:2] (and, maybe, help fixing).


** 3. Small community

This is more related to how recent all these libraries are. They don't
have a large user base like the monolithic frameworks. So it may be
quite more difficult to find an answer to problems you're facing.

It's also likely that the library will have problems that people using
more mature and larger frameworks have already reported. And these would
take a bit to fix as well.


** 4. Trying to solve problems they're not meant to

According to the buzz on the internets, microlibs are supposed to do
/only one thing and do it well™/, but in practice, that's not
true. Almost all of these libraries will provide fallbacks for
features that are not related to the design goals of the library,
and worse, for features that are described in the [[http://es5.github.com][ECMAScript 5]]
specs.

Yes, I'm looking at all of the libraries that implement
[[mdn:Array/indexOf][Array#indexOf]], [[mdn:Array/filter][Array#filter]], [[mdn:Function/bind][Function#bind]] and such
fallbacks, when the library tries to solve an entire different problem.

This creates two problems. The first is that now instead of having dead
code, you have *duplicated code*. It's even worse if you're only
targeting platforms which are ES5-compliant, because now you have
*duplicated dead code*.

The second problem is that some of these libraries implement things that
don't conform with the specs. And I'm not too keen on having 20
different implementations of [[mdn:Array/indexOf][Array#indexOf]] which don't work for
sparse arrays, thank you.


** 5. API inconsistencies

You can't expect to get API consistencies when using libraries from 10
different authors if they're not designed to work together, which you'd
get for free on JavaScript frameworks (or would you?[fn:3]). 

This can be really bad when you need to have two libraries to work
together, say a CSS selector engine and a DOM manipulation library. Of
course you can abstract all of them and create a DSL on top of them,
just as you could read a minified source rather than a properly
commented one...


** 6. Dependency hell

Browsers still don't offer native support for modules, although it's
[[http://wiki.ecmascript.org/doku.php?id%3Dharmony:modules][being discussed for ES.Next]], nor can you use ~jspm install microlib~ and
have all the dependencies sorted out nicely for you.

The thing is that using lots of small libraries will make your building
and testing process quite more complex. Where you had to include a
simple script tag to load everything you need, you'll need to include
loads of them (in the right order too), or have something that
automagically concatenates those files in the right order.

Either way, it's quite some hassle.


** 7. Focus on arbitrary filesize

Having a soft-limit for filesize isn't necessarily a bad thing. It helps
you to know when you're over-engineering things. However, 
not all the problems are the same that you can happily have a
[[http://tomdale.net/2011/05/an-uphill-battle/][5kb limit for everynyan]].

With the microlibs, things have somehow gotten screwed up and the focus
that should be into "*reducing the scope of the library for modularity*"
(think minimalism), turned into a battle for who could fit an entire DOM
library in a tweet.

I find this whole premature and reckless optimisation for filesize
pretty stupid, of course. [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-7.html][As Sussman says]]:

#+BEGIN_QUOTE
Programs must be written for people to read, and only incidentally for
machines to execute.
#+END_QUOTE

Programs should also be written for correctness and to effectively solve
the problems they propose to solve, but I guess everyone knows that
already...


* What can we do?

So, large and bloated frameworks are a bad idea for web apps, but the
current state of microlibs is also pretty bad. That's no fun, and
definitely not good for the community, right?

The obvious answer to these problems is to focus on writing modular
libraries. And when I say /modular/, I'm referring to libraries that fit
the Unix philosophy.

They should be designed to solve just one problem, and solve it well, so
people can decide exactly which problems they want to solve instead of
getting a large black box that tries to solve everything.

They should also be designed to work nicely with other libraries,
otherwise what's the point in having modular stuff anyways? You'll most
likely never have to solve just a single problem when writing a web
app.


** A new design philosophy

In fact, we can summarise it nicely in a list of few points to keep in
mind when designing a library. Mostly stolen from Eric Raymond's The Art
of Unix Programming book:

- Modularity    ::
  Write simple parts connected by clean interfaces.

- Composition   ::
  Design libraries to be connected to other libraries.

- Simplicity    ::
  Design for simplicity; add complexity only where you must.

- Correctness   ::
  If it doesn't *fully* solves the problem it's designed to solve, it's
  broken.

- Lazyness      ::
  Don't try to solve what's already solved; stop writing broken ES5
  fallbacks.

- Parsimony     ::
  Write big libraries only when it's clear by demonstration that nothing
  else will do.

- Optimisation  ::
  Prototype before polishing. Get it working before you optimise it (be
  it for size, speed or anything else).

- Extensibility ::
  Design for the future, because it will be here sooner than you think
  (modules are a good thing, and they'll be added to the language!)


** Problems with this philosophy

Obviously, these points are not anything near perfect. And it gets worse
if you take the current state of browser platforms into account. The web
is quite heterogeneous. Even on browsers who do conform with the
standards, you still have some quite funny discrepancies on
the inner workings — and that affects your code.

To make things yet worse, you don't have much things to solve the
dependency hell, aside from writing a custom build tool. And even so,
you'll likely need to download and build a set of different libraries to
get everything working.

This is not exactly my definition of fun.

For this to really work, we'd need a good package manager; like what [[http://github.com/isaacs/npm][npm]]
is to [[http://nodejs.org][Node.js]]. And we would also need either some support for loading
these external modules in a sane way (you do [[http://github.com/killdream/jello][have]] [[http://requirejs.org][some]] [[http://labjs.com][libraries]] [[http://news.ycombinator.com/item?id%3D2300423][for
that]]), rather than having to do with build scripts.


* Wrapping it up

There's no such thing as *one true way*. I don't think modular
libraries/frameworks solve all the problems, but they do address quite
some of the problems we have with the current models of libraries.

And it would be nice having a healthier environment for developing new
awesome apps on the Browser, without having to write everything from
scrath again because the thing you need is only included in another
library, and it uses a framework-centric approach.

All in all, it's something I think would benefit the JavaScript
community as a whole :3


[fn:1] I hate using the term "framework" to refer to libraries with all
       my guts. Seriously, people, is `library` **that** hard to spell?


[fn:2] I'll work on tests and documentation for [[http://github.com/killdream/ekho][Ekho]] and friends when I
       have time to do so. Probably after I finish some of the core
       concepts/early prototypes for [[http://killdream.github.com/orpheos][OrpheOS]]. Until then, considering
       the library a beta release may be a good thing.


[fn:3] I don't think PrototypeJS has a consistent API, for
       example. Though Ruby people might say otherwise, it just strikes
       me as odd if you use ~bindAsEventListener~ and ~gsub~ randomly on
       your API (I would never take a Ruby programmer's word on good API
       design anyways ;P). jQuery's API on the other hand (although I've
       only used a small subset of it for a short time) is just a mess
       of counter-intuitive and poorly-named methods. People should stop
       getting inspired by PHP when designing an API...
