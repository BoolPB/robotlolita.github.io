#+STARTUP: showall hidestars indent
#+OPTIONS: ^:{}
#+BEGIN_HTML
---
layout: post
title:  Understanding JavaScript OOP
snip:   Prototypical inheritance on awesomeness!
---
#+END_HTML

JavaScript is an object oriented language, with its roots in the [[http://selflanguage.org/][Self]]
programming language, however (sadly) designed to look like Java. This
makes the language's really powerful and sweet features stay covered by
some pretty ugly and counter-intuitive /work-arounds/.

One of such affected features is the implementation of prototypical
inheritance. The concepts are simple yet flexible and powerful. It makes
inheritance and behaviourism first-class citizens, just like functions
are first-class in functional-ish languages (JavaScript included).

Fortunately, [[http://www.ecma-international.org/publications/standards/Ecma-262.htm][ECMAScript 5]] has gotten plenty of things to move the
language in the right way, and it's on those sweetness that this article
will expand on. Though I'll also cover the drawbacks of JavaScript's
design, and do a little comparison with the classical model here and
there, where those would highlight the advantages or disadvantages of
the language's implementation of prototypical OO.

It's important to note, though, that this article assumes you have
knowledge over other basic JavaScript functionality, like functions
(including the concepts of closures and first-class functions),
primitive values and such.



* 1. Objects

Everything you can manipulate in JavaScript is an object. This includes
~Strings~, ~Arrays~, ~Numbers~, ~Functions~, and, obviously, the
so-called ~Object~. An object in the language is simply a collection of
key/value pairs (and a few internal magic sometimes).

There are no concepts of classes anywhere, though. That is, an object
with properties ~name = Linda~ is not an instance of the ~Object~
class. They are entirely separate *instances* that /fully/ define
their own behaviour. That is, objects are instances of themselves in
JavaScript, there are no layers of meta-data (i.e.: classes) to provide
how an object of a certain type must look like.

You might ask: "how?". More so if you come from a highly classical
Object Orientation background (like Java or C#). Wouldn't having each
object define their own behaviour, instead of a common /class/ mean that
if I have 100 objects, I will have 100 different methods? Also, isn't it
dangerous? How would one know if an object is really an Array, for
example?

Well, to answer all those questions, we'll first need to unlearn
everything about the classical OO approach and start from the ground
up. But, trust me, it's worth it. The prototypical OO model brings in
some new ways of solving old problems, in an easier and more dynamic
way. It also presents new and more powerful models for extensibility and
code-reuse, which is what most people are interested about when they
talk about Object Orientation.


** 1.1. What are objects?

As mentioned previously, objects are simple pairs of unique keys that
correspond to a value — we'll call this pair a ~property~. So, suppose
you'd want to describe a few aspects of an old friend — let's call it
~Mikhail~, like age, name and gender:

#+begin_src plantuml :file ../media/assets/oop-obj-mikhail.png :exports none
skinparam defaultFontName DejaVu Sans Mono
skinparam defaultFontSize 16

object Mikhail {
  <b>name:</b>   "Mikhail"
  <b>age:</b>    19
  <b>gender:</b> "Male"
}
#+end_src

#+results:
[[file:../media/assets/oop-obj-mikhail.png]]

[[blog:oop-obj-mikhail.png]]

Objects are created in JavaScript using the ~Object.create~ function. It
takes a parent and an optional list of property descriptors and makes a
brand new instance. Though, we'll not worry much about the parameters
now.

An empty object is an object with no parent, and no properties. The
syntax to create such object in JavaScript is the following:

#+begin_src js
var mikhail = Object.create(null)
#+end_src


** 1.2. Creating properties

So, now we have an object, but no properties — we've got to fix that if
we want to describe ~Mikhail~.

Properties in JavaScript are dynamic. That means that they can be
created or removed at any time. Properties are also unique, in the sense
that a property name inside an object correspond to exactly one value.

Creating new properties is done through the =Object.defineProperty=
function, which takes a reference to an object, the name of the property
to create and a descriptor that defines the semantics of the property.

#+begin_src js
Object.defineProperty(mikhail, 'name', { value:        'Mikhail'
                                       , writable:     true
                                       , configurable: true
                                       , enumerable:   true })

Object.defineProperty(mikhail, 'age', { value:        19
                                      , writable:     true
                                      , configurable: true
                                      , enumerable:   true })

Object.defineProperty(mikhail, 'gender', { value:        'Male'
                                         , writable:     true
                                         , configurable: true
                                         , enumerable:   true })
#+end_src

=Object.defineProperty= will create a new property if a property with
the given name does not exist in the object, otherwise it'll update the
semantics and value of the existing property.


** 1.3. Descriptors

Descriptors are the little object that carry the semantics of a property
(we used them in the previous =Object.defineProperty= calls).

A descriptor may be a data descriptor — it holds a concrete value — or
an accessor descriptor — it proxies the access to the concrete value
through getters and setter functions.

All the descriptors share the following attributes. Whenever these are
not given, they default to =false=.

- writable ::
  Whether the concrete value of the property may be changed.

- configurable ::
  Whether the type of descriptor may be changed, or if the property can
  be removed.

- enumerable ::
  Whether the property is listed in a loop through the properties of the
  object.

Data descriptors can have the following attribute. Defaults to
=undefined= when not given.

- value ::
  The value of a property.

Accessor descriptors can have the following attributes. Defaults to
=undefined= when not given.

- get () ::
  A function called with no arguments when the property value is
  requested.

- set (new_value) ::
  A function called with the new value for the property when the user
  tries to modify the value of the property.


** 1.4. Ditching the verbosity

Luckily, property descriptors are not the only way of working with
properties in JavaScript, they can also be handled in a sane and concise
way.

JavaScript also understands references to a property using what we call
/bracket notation/. The general rule is:

#+begin_src bnf
<bracket-access> ::= <identifier> "[" <expression> "]"
#+end_src

Where =identifier= is the variable that holds the object containing the
properties we want to access, and =expression= is any valid JavaScript
expression that defines the name of the property. There are no
constraints in which name a property can have[fn:1], everything is fair
game.

Thus, we could just as well rewrite our previous example as:

#+begin_src js
mikhail['name']   = 'Mikhail'
mikhail['age']    = 19
mikhail['gender'] = 'Male'
#+end_src

⁣

- Note ::

  All property names are ultimately converted to a String, such that
  =object[1]=, =object[⁣[1]⁣]=, =object['1']= and =object[variable]= (when
  the variable resolves to =1=) are all equivalent.

There is another way of referring to a property called /dot
notation/, which usually looks better (and presents less syntactical
noises) than the bracket alternative, however it only works when the
property name is a [[http://es5.github.com/#x7.6][valid JavaScript identifier]], and don't allow
for arbitrary expressions (so, variables here are a no-go).

The rule for /dot notation/ is:

#+begin_src bnf
<dot-access> ::= <identifier> "." <identifier>
#+end_src

This would give us an even sweeter way of defining properties:

#+begin_src js
mikhail.name   = 'Mikhail'
mikhail.age    = 19
mikhail.gender = 'Male'
#+end_src

Both of these syntaxes are equivalent to creating a data property, with
all semantic flags set to =true=.


[fn:1]: Some implementations have magical names, like =__proto__=, which
        may yield undesired and unwanted results when set. For example,
        =__proto__= property is used to define the parent of an object
        in some implementations. As such, you wouldn't be able to set a
        string or number to that.


** 1.5. Accessing properties

Retrieving the values stored in a given property is as easy as creating
new ones, and the syntax is mostly similar as well — the only difference
being there isn't an assignment.

So, if we want to check on Mikhail's age:

#+begin_src js
mikhail['age']
// => 19
#+end_src

Trying to access a property that does not exist in the object simply
returns =undefined=:

#+begin_src js
mikhail['address']
// => undefined
#+end_src


** 1.6. Removing properties

To remove entire properties from an object, JavaScript provides the
=delete= operator. So, if you wanted to remove the ~gender~ property
from the ~mikhail~ object:

#+begin_src js
delete mikhail['gender']
// => true

mikhail['gender']
// => undefined
#+end_src

The =delete= operator returns =true= if the property was removed,
=false= otherwise. I won't delve into details of the workings of this
operator, since [[http://twitter.com/kangax][@kangax]] has already written a
[[http://perfectionkills.com/understanding-delete/][most awesome article on how delete works]].


** 1.7. Getters and setters

Getters and setters are usually used in classical object oriented
languages to provide encapsulation. They are not much needed (or wanted)
in JavaScript, though, given how dynamic the language is — +and my bias
against the feature+.

At any rate, they allow you to proxy the requests for reading a property
value or setting it, and decide how to handle each situation. So,
suppose we had separate slots for our object's first and last name, but
wanted a simple interface for reading and setting it.

First, let's set the first and last names of our friend, as concrete
data properties:

#+begin_src js
Object.defineProperty(mikhail, 'first_name', { value:    'Mikhail'
                                             , writable: true })

Object.defineProperty(mikhail, 'last_name', { value:    'Weiß'
                                            , writable: true })
#+end_src

Then we can define a common way of accessing and setting both of those
values at the same time — let's call it ~name~:

#+begin_src js
// () → String
// Returns the full name of object.
function get_full_name() {
    return this.first_name + ' ' + this.last_name
}

// (new_name:String) → undefined
// Sets the name components of the object, from a full name.
function set_full_name(new_name) { var names
    names = new_name.trim().split(/\s+/)
    this.first_name = names[0] || ''
    this.last_name  = names[1] || ''
}

Object.defineProperty(mikahil, 'name', { get: get_full_name
                                       , set: set_full_name
                                       , writable:     true
                                       , configurable: true
                                       , enumerable:   true })
#+end_src

Now, every-time we try to access the value of Mikhail's =name= property,
it'll execute the =get_full_name= getter:

#+begin_src js
mikhail.name
// => 'Mikhail Weiß'

mikhail.first_name
// => 'Mikhail'

mikhail.last_name
// => 'Weiß'

mikhail.last_name = 'White'
mikhail.name
// => 'Mikhail White'
#+end_src

We can also set the name of the object, by assigning a value to the
property:

#+begin_src js
mikhail.name = 'Michael White'

mikhail.name
// => 'Michael White'

mikhail.first_name
// => 'Michael'

mikhail.last_name
// => 'White'
#+end_src


** 1.8. Listing properties

Since properties are dynamic, JavaScript provides a way of checking out
which properties an object define. There are two ways of listing the
properties of an object, depending on what kind of properties one is
interested into.

The first one is done through a call to =Object.getOwnPropertyNames=,
which returns an =Array= containing the names of *all* properties set in
the object.

If we check now what we know about Mikhail:

#+begin_src js
Object.getOwnPropertyNames(mikhail)
// => [ 'name', 'age', 'gender', 'first_name', 'last_name' ]
#+end_src

The second way is using =Object.keys=, which returns all properties that
have been marked as *enumerable* when they were defined:

#+begin_src js
Object.keys(mikhail)
// => [ 'name', 'age', 'gender' ]
#+end_src


** 1.9. Object literals

An even easier way of defining objects is to use the object literal
(also called /object initialiser/) syntax that JavaScript provides. An
object literal denotes a fresh object, that has it's parent as the
=Object.prototype= object. We'll talk more about parents when we visit
inheritance, later on.

At any rate, the object literal syntax allows you to define simple
objects and initialise it with properties at the same time. So, we could
rewrite our Mikhail object to the following:

#+begin_src js
var mikhail = { first_name: 'Mikhail'
              , last_name:  'Weiß'
              , age:        19
              , gender:     'Male'

              // () → String
              // Returns the full name of object.
              , get name() {
                    return this.first_name + ' ' + this.last_name }

              // (new_name:String) → undefined
              // Sets the name components of the object,
              // from a full name.
              , set name(new_name) { var names
                    names = new_name.trim().split(/\s+/)
                    this.first_name = names[0] || ''
                    this.last_name  = names[1] || '' }
              }
#+end_src

Property names that are not valid identifiers must be quoted. Also note
that the getter/setter notation for object literals strictly defines a
new anonymous function. If you want to assign a previously declared
function to a getter/setter, you need to use the =Object.defineProperty=
function.

The rules for object literal can be described as the following:

#+begin_src bnf
<object-literal>  ::= "{" <property-list> "}"
                    ;
<property-list>   ::= <property> ["," <property>]*
                    ;
<property>        ::= <data-property>
                    | <getter-property>
                    | <setter-property>
                    ;
<data-property>   ::= <property-name> ":" <expression>
                    ;
<getter-property> ::= "get" <identifier>
                    :       <function-parameters>
                    :       <function-block>
                    ;
<setter-property> ::= "set" <identifier>
                    :       <function-parameters>
                    :       <function-block>
                    ;
<property-name>   ::= <identifier>
                    | <quoted-identifier>
                    ;
#+end_src

Object literals can only appear inside expressions in
JavaScript. Since the syntax is ambiguous to block statements in the
language, new-comers usually confound the two:

#+begin_src js
  // This is a block statement, with a label:
  { foo: 'bar' }
  // => 'bar'

  // This is a syntax error (labels can't be quoted):
  { "foo": 'bar' }
  // => SyntaxError: Invalid label

  // This is an object literal (note the parenthesis to force
  // parsing the contents as an expression):
  ({ "foo": 'bar' })
  // => { foo: 'bar' }

  // Where the parser is already expecting expressions,
  // object literals don't need to be forced. E.g.:
  var x = { foo: 'bar' }
  fn({foo: 'bar'})
  return { foo: 'bar' }
  1, { foo: 'bar' }
  ( ... )
#+end_src


* 2. Methods

Up until now, the Mikhail object only defined slots of concrete data —
with the exception of the name getter/setter. Defining actions that may
be performed on a certain object in JavaScript is just as simple.

This is because JavaScript does not differentiate how you can manipulate
a ~Function~, a ~Number~ or an ~Object~. Everything is treated the same
way (i.e.: functions in JavaScript are first-class).

As such, to define an action for a given object, you just assign a
function object reference to a property. Let's say we wanted a way of
Mikhail to greet someone:

#+begin_src js
// (person:String) → String
// Greets a random person
mikhail.greet = function(person) {
    return this.name + ': Why, hello there, ' + person + '.'
}
#+end_src

After setting the property, we can use it the same way we used the
concrete data that were assigned to the object. That is, accessing the
property will return a reference to the function object stored there, so
we can just call it:

#+begin_src js
mikhail.greet('you')
// => 'Michael White: Why, hello there, you.'

mikhail.greet('Kristin')
// => 'Michael White: Why, hello there, Kristin'
#+end_src


** 2.1. Dynamic =this=

One thing that you must have noticed both on the =greet= function, and
on the functions we've used for the =name='s getter/setter, is that they
use a magical variable called =this=.

This variable is accessible inside any function in JavaScript, and holds
a reference to the object that the function is being applied to. Note
that this does not necessarily means that =this= will equal the object
where the function is *stored*.

That is, in JavaScript, what =this= refers to is resolved dynamically,
at the time the function is called, and depending only on how such a
function is called.

Having =this= dynamically resolved is an incredible powerful mechanism
for the dynamism of JavaScript's object orientation and lack of
strictly enforced structures (i.e.: classes), this means one can apply a
function to any object that meets the requirements of the actions it
performs, regardless of how the object has been constructed.


** 2.2. How =this= is resolved

There are four different ways of resolving the =this= variable in a
function, depending on how a function is called.

For the following examples, we'll take these definitions into account:

#+begin_src js
// (other:Number[, yet_another:Number]) → Number
// Returns the sum of the object's value with the given Number
function add(other, yet_another) {
    return this.value + other + (yet_another || 0)
}

var one = { value: 1, add: add }
var two = { value: 2, add: add }
#+end_src


*** 2.2.1. Called as a method

If a function is called as an object's method, then =this= inside the
function will refer to the object. That is, when we explicitly state
that an object is carrying an action, then that object will be our
=this= inside the function.

This is what happened when we called =mikhail.greet()=. The property
access at the time of the call, tells JavaScript that we want to apply
whatever actions the =greet= function defines to the =mikhail= object.

#+begin_src js
one.add(two.value) // this === one
// => 3

two.add(3)         // this === two
// => 5
#+end_src


*** 2.2.2. Called directly

When a function is called directly, =this= will be resolved to the
global object in the engine (e.g.: =window= in browsers, =global= in
Node.js)

#+begin_src js
add(two.value)  // this === global
// => NaN

// The global object still has no `value' property, let's fix that.
value = 2
add(two.value)  // this === global
// => 4
#+end_src


*** 2.2.3. Explicitly applied

Finally, a function may be explicitly applied to any object, regardless
of whether the object has the function stored as a property or
not. These applications are done through a either the =call= or =apply=
method of a function object.

The difference between these two methods is the way they take in the
parameters that will be passed to the function, and the performance —
=apply= being up to 55x slower than a direct call, whereas =call= is
usually not as bad. This might vary greatly depending on the engine
though, so it's always better to do a [[http://jsperf.com][Perf test]] rather than being scared
of using this functionality.

Anyways, =call= expects the object that the function will be applied to
as the first parameter, and the parameters to apply to the function as
positional arguments:

#+begin_src js
add.call(two, 2, 2)      // this === two
// => 6

add.call(window, 4)      // this === global
// => 6

add.call(one, one.value) // this === one
// => 2
#+end_src

On the other hand, =apply= lets you pass an array of parameters as the
second parameter of the function. The array will be passed as positional
arguments to the target function:

#+begin_src js
add.apply(two, [2, 2])
// => 6

add.apply(window, [4])
// => 6

add.apply(one, [one.value])
// => 2
#+end_src

- Note ::

  What =this= resolves to when applying a function to a non-object (like
  =null= or =undefined=) depends on the semantics used by the
  engine. Usually, this would be the same as explicitly applying the
  function to the global object. But if the engine is running on [[https://developer.mozilla.org/en/JavaScript/Strict_mode][strict
  mode]], then =this= will be resolved as expected — to the exact thing it
  was applied to.


** 2.3. Bound methods

Aside from the dynamic nature of functions in JavaScript, there is also
a way of making a function bound to an specific object, such that =this=
inside that function will always resolve to the given object, regardless
of whether it's called as that object's method or directly.

The function that provides such functionality is =bind=. It takes an
object, and additional parameters (in the same manner as =call=), and
returns a new function that will apply those parameters to the original
function when called:

#+begin_src js
var one_add = add.bind(one)

one_add(2) // this === one
// => 3

two.one_adder = one_add
two.one_adder(2) // this === one
// => 3

one_add.call(two) // this === one
// => 3
#+end_src


* 3. Inheritance
** 3.1. How =[⁣[Prototype]⁣]= works
** 3.2. Delegated property access
** 3.3. Type checking
** 3.4. Super methods
** 3.5. Mixins


* 4. Constructors
** 4.1. The =new= magic

* 5. Considerations and compatibility
** 5.1. Creating objects
** 5.2. Defining properties
** 5.3. Listing properties
** 5.4. Bound methods
** 5.5. Libraries that provide fallbacks

* 6. Wrapping it up
* 7. Things worth reading up next
