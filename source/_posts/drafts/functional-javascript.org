#+STARTUP: showall indent
#+OPTIONS: ^:{}
#+BEGIN_HTML
---
layout: post
title:  Functional JavaScript
snip:   Bringing parens back to JS, without the parens.
---
#+END_HTML

Functional programming is becoming a hot topic these days. Programmers
are (re-)discovering functional idioms in their old languages, and new
languages often feature multiple paradigms, with support to functional
idioms to a certain extent — even Java is getting lambda expressions!

JavaScript is one of these multiple paradigm languages, taking its
functional side from [[http://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]], a minimal dialect of the [[http://en.wikipedia.org/wiki/Lisp_programming_language][Lisp]] family. It
is, however, at the same time, a language designed for monkey patching,
which means that side-effects are tied straight into the core of the
language.

This raises several questions on the validity of stating that JavaScript
allows for functional idioms. In this article we'll go through what
functional programming really is, how it applies to JavaScript and which
kind of new and interesting compositional patterns it allows in the
language.


* Introduction

So, what's this "functional programming" business anyways?

Well, functional programming has a fuzzy meaning these days (only not as
fuzzy as /Object Oriented Programming/, I think). But in essence,
functional programming languages revolve around computing expressions,
rather than changing some global state through a series of statements.

The major requirement for a programming language to support functional
programming idioms is that functions *must be first-class[fn:1]*
citizens. That is, functions need to be treated as any other value in
the language, which means being able to pass them as arguments to other
functions, store them in variables and return them from other functions,
usually.

Modern functional languages include several other features to improve
the language's expressiveness, and make it easier to reason about a
given program. Those include closures, higher-order functions,
referential transparency and lazy evaluation.
 
[fn:1]: *first-class* is not a well-defined term, actually. It depends
        mostly on how other kinds of primitive values are treated in the
        language. The rights of function objects should be at least the
        same as those. In JavaScript, in addition to the rights
        mentioned above, functions can also store properties, since
        that's something every object in the language can do.


** The basic theory

The idea of functional abstracions comes from Alonzo Church's
[[http://en.wikipedia.org/wiki/Lambda_calculus][lambda calculus]], which
intended to use functions as the foundation of mathematics. The lambda
calculus semantics defines computations and values as a series of lambda
expressions. These expressions are evaluated through a series of
reductions that take an abstraction to the value it represents.

Take the following mathematical expression: =2 + 3 * (5 / 2) - 1=. We
can compute the value of the expression by reducing it to a value:

#+begin_src text
  = 2 + 3 * (5 / 2) - 1
  = 2 + 3 * (2.5) - 1
  = 2 + 7.5 - 1
  = 9.5 - 1
  = 8.5
#+end_src

In lambda calculus, a similar series of reductions is used to evaluate a
lambda expression:

#+begin_src text
  calc = (λa → λb → λc → λd → a + b * (c / a) - d) 2
       = (λb → λc → λd → 2 + b * (c / 2) - d) 3
       = (λc → λd → 2 + 3 * (c / 2) - d) 5
       = (λd → 2 + 3 * (5 / 2) - d) 1
       = (2 + 3 * (5 / 2) - 1)
       = 2 + 3 * (2.5) - 1
       = 2 + 7.5 - 1
       = 9.5 - 1
       = 8.5
#+end_src

The biggest difference is that, instead of defining the numbers directly
in the expression, we abstract that into /lambda abstractions/. That is,
we have functions that take numbers as arguments for the computation,
and they return other lambda abstractions.

When a lambda abstraction is applied to a number, we substitute all the
terms with the same name as the lambda abstraction parameter by that
number.

That is, =2= could be abstracted as =λx → x= (a lambda abstraction
taking =x=, and immediately yielding =x=)[fn:2], and then we could apply
numbers to get them back: =(λx → x) 2= would yield =2=.


[fn:2]: The lambda abstraction =λx → x= is also called *Identity* (or I,
        for short). And it's a core combinator in Lambda Calculus. The
        combinators are: =I: λx → x=, =K: λx → λy → x=, 
        =S: λx → λy → λz → x z (y z)=. You could express any computation
        using only those combinators.


** Why use functional programming?

Functional idioms provide an alternative method for composing programs,
which tends to lead themselves more easily to a good deal of modularity,
given the emphasis placed in purity, abstractions — usually in terms
of higher-order functions — and declarative definitions of the
computation being performed.

The declarative definitions are usually self-explanatory on which
operation is carried about — rather than how. Which helps conveying the
intent of such a piece of code. On the other hand, it makes it a little
more difficult to understand the /how things get done/ part.

These properties can, arguably, make the resulting application a great
deal shorter, less complex, and easier to inspect and reason about, for
the programmer has to keep less information on his head at any given
time.


* Functions

Functions are, basically, a means of abstracting computations, as
discussed previously in the section on the theory behind functional
programming. This means that if I have the expression =2 + 2=, I can
have a function that abstracts over that expression[fn:3]:

#+begin_src js
  2 + 2
  // => 4

  function two_plus_two() { return 2 + 2 }
  two_plus_two()
  // => 4
#+end_src

[fn:3]: While this generic claim may still hold true for JavaScript,
        it's important to note that functions in the language don't
        respect Tennet's Correspondence Principle, such you can't just
        wrap every expression in a function while preserving the
        properties of the expression before wrapping it.


** Definition

There are two ways for defining a function in ECMAScript, which depends mostly
on the context which such definition happens. Both ways are equivalent,
however, in the sense that they both create a function object with the same
properties.

First, we have what the [[http://es5.github.com/#x13][specs]] call a =FunctionDeclaration=, which happens at
the statement level. Since statements are things that yield no value, a
=FunctionDeclaration=, instead of returning a function object, binds that
object to the current scope, with the name the function was declared with.

This means that if we declare a function named =square= in this manner, we can
refer to it right away by that name:

#+BEGIN_SRC js
  function square(x) { return x * x }

  square(2)
  // => 4
#+END_SRC

An interesting property of =FunctionDeclarations= is that they are *hoisted*[fn:4],
that is, regardless of where you declare them in your source code, they will be
available anywhere in the scope. This allows for interesting orderings of a
program's source code, without being bound by the evaluation order:

#+BEGIN_SRC js
  square(2)
  // => 4

  function square(x) { return x * x }
#+END_SRC

The other way of creating a function object is by what the specs call a
=FunctionExpression=. The syntax is the same as a =FunctionDeclaration=, except
the function's name is optional. Rather than binding the resulting function
object to the current scope, a =FunctionExpression= works by making that
function object the result of the expression.

It might sound a bit insane at first, but this is an extremely powerful
feature in the presence of first-class functions. We can decide when we
want to treat a function as an object — a value we can manipulate, — or
execute it.

#+BEGIN_SRC js
  var square_of = function(x){ return x * x }
#+END_SRC

Now, we have a variable =square= that holds a function which, when
called with a numeric parameter, computes the square of that
number:

#+BEGIN_SRC js
  square_of(3)
  // => 9
#+END_SRC

Note that when you want to execute a function you need to use the
additional parenthesis. Otherwise, the function is just treated as a
regular object. The act of executing a function is also referred to as
=calling=, or more formally =applying= a function to some arguments.

[fn:4]: Hoisting is considered by many a misfeature. I think it has its uses,
        though it can be obviously abused. One of the interesting properties it
        allows is a more natural ordering of a program's source code, or even a
        little of literate programming.


** Parameters
** Arity
** Application
* Scoping
** Lexical scoping
** Scope chain
** Environments
** Closures
* Patterns
** Recursion
** Higher-order functions
* Practical applications
** Currying and uncurrying
** Composition
** Memoisation
** Encapsulation
