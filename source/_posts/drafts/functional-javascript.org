#+STARTUP: showall indent
#+OPTIONS: ^:{}
#+BEGIN_HTML
---
layout: post
title:  Functional JavaScript
snip:   Bringing parens back to JS, without the parens.
---
#+END_HTML

Functional programming is becoming a hot topic these days. Programmers
are (re-)discovering functional idioms in their old languages, and new
languages often feature multiple paradigms, with support to functional
idioms to a certain extent — even Java is getting lambda expressions!

JavaScript is one of these multiple paradigm languages, taking its
functional side from [[http://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]], a minimal dialect of the [[http://en.wikipedia.org/wiki/Lisp_programming_language][Lisp]] family. It
is, however, at the same time, a language designed for monkey patching,
which means that side-effects are tied straight into the core of the
language.

This raises several questions on the validity of stating that JavaScript
allows for functional idioms. In this article we'll go through what
functional programming really is, how it applies to JavaScript and which
kind of new and interesting compositional patterns it allows in the
language.


* Introduction

So, what's this "functional programming" business anyways?

Well, functional programming has a fuzzy meaning these days (only not as
fuzzy as /Object Oriented Programming/, I think). But in essence,
functional programming languages revolve around computing expressions,
rather than changing some global state through a series of statements.

The major requirement for a programming language to support functional
programming idioms is that functions *must be first-class[fn:1]*
citizens. That is, functions need to be treated as any other value in
the language, which means being able to pass them as arguments to other
functions, store them in variables and return them from other functions,
usually.

Modern functional languages include several other features to improve
the language's expressiveness, and make it easier to reason about a
given program. Those include closures, higher-order functions,
referential transparency and lazy evaluation.
 
[fn:1]: *first-class* is not a well-defined term, actually. It depends
        mostly on how other kinds of primitive values are treated in the
        language. The rights of function objects should be at least the
        same as those. In JavaScript, in addition to the rights
        mentioned above, functions can also store properties, since
        that's something every object in the language can do.


** The basic theory

The idea of functional abstracions comes from Alonzo Church's [[http://en.wikipedia.org/wiki/Lambda_calculus][lambda
calculus]], which intended to use functions as the foundation of
mathematics. The lambda calculus semantics defines computations and
values as a series of lambda expressions. These expressions are
evaluated through a series of reductions that take an abstraction to the
value.

Take, the following mathematical expression: =2 + 3 * (5 / 2) - 1=. We
can compute the value of the expression by reducing it to a value:

#+begin_src text
  = 2 + 3 * (5 / 2) - 1
  = 2 + 3 * (2.5) - 1
  = 2 + 7.5 - 1
  = 9.5 - 1
  = 8.5
#+end_src

In lambda calculus, a similar series of reductions is used to evaluate a
lambda expression:

#+begin_src text
  calc = (λa → λb → λc → λd → a + b * (c / a) - d) 2
       = (λb → λc → λd → 2 + b * (c / 2) - d) 3
       = (λc → λd → 2 + 3 * (c / 2) - d) 5
       = (λd → 2 + 3 * (5 / 2) - d) 1
       = (2 + 3 * (5 / 2) - 1)
       = 2 + 3 * (2.5) - 1
       = 2 + 7.5 - 1
       = 9.5 - 1
       = 8.5
#+end_src

The biggest difference is that, instead of defining the numbers directly
in the expression, we abstract that into /lambda abstractions/. That is,
we have functions that take numbers as arguments for the computation,
and they return other lambda abstractions.

When a lambda abstraction is applied to a number, we substitute all the
terms with the same name as the lambda abstraction parameter by the
number it was applied to.

That is, =2= could be abstracted as =λx → x= (a lambda abstraction
taking =x=, and immediately yielding =x=)[fn:2], and then we could apply
numbers to get them back: =(λx → x) 2= would yield =2=.


[fn:2]: The lambda abstraction =λx → x= is also called *Identity* (or I,
        for short). And it's a core combinator in Lambda Calculus. The
        combinators are: =I: λx → x=, =K: λx → λy → x=, 
        =S: λx → λy → λz → x z (y z)=. You could express any computation
        using only those combinators.


** Why use functional programming?

Functional idioms aid making programs more structured and modular, since
they make it easier to create abstractions over recurring patterns. This
means that one can build programs that lead themselves naturally to a
more declarative — therefore more readable — components, that interface
with each other through the abstractions defined.

Functional programs are often shorter and present less complexity
up-front than their imperative counterparts. And since functional idioms
value purity, these programs are also easier to reason about, because
the programmer doesn't have to build and maintain the whole application
state on his head when reading a piece of code.


* Functions
** Definition
** Parameters
** Application
* Scoping
** Lexical scoping
** Scope chain
** Environments
** Closures
* Patterns
** Recursion
** Higher-order functions
* Practical applications
** Currying and uncurrying
** Composition
** Memoisation
** Encapsulation
