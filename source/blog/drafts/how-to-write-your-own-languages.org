#+STARTUP: showall hidestars indent
#+BEGIN_HTML
---
layout: post
title:  How To Write Your Own Programming Languages
snip:   Some people say writing PLs is difficult. I say it couldn't be easier!!1
---
#+END_HTML

I've heard it a lot, people saying that writing your own programming languages
is so difficult only a selected few programmers are able to do it. Well,
writing smart compilers is difficult, writing decent JITs is difficult, but
writing programming languages is actually rather easy: it's just about tree
transformations.

In this blog post I'll show you how simple tree transformations and pattern
matching make the task of writing a programming language. We'll use [[http://www.tinlizzie.org/ometa/][OMetaJS]] for
writing both the parser and the compiler. OMeta is interesting for this because
it generalises parsing, optimising and compiling as tree transformations, which
is actually the essence of those.

In a sense, this is a tutorial about OMetaJS, but it's also a more general
article on an introduction to the design of programming languages. It's a
*huge* topic, so don't expect me to cover everything. However, it's a good
starting point to see if you'll be interested in digging more into the awesome
field of Programming Language Theory :3


* 0. Introduction

This is an article on the basics of programming language design. As an
introduction to the topic, I've dropped most of the mathematical formalism and
advanced techniques for complex semantics. But I'll try to give pointers as to
how you'd go about the whole process which will hopefully be enough for writing
a few hobby-ist DSLs.

The article is structured in 6 sections, a conclusion and an appendix. First
section provides an overview to the concept of programming languages, and why
you would want to write a new one at all. That's followed by a section on the
semantics of programming languages and how we encode semantics for a human
programmer (syntax). These sections have very little mathematical formalism,
and provide an overview of the subset of PLT we'll be using throughout the
article. They also present the language we'll be building.

Sections 4, 5 and 6 go about how we encode the syntax and semantics of our
programming language using OMetaJS. We'll be using Node here just because it
makes everything simpler, but you could just as well follow the article using
the [[http://www.tinlizzie.org/ometa-js/][OMetaJS playground]]. These sections basically go about explaining the
process of parsing, optimising and compiling as generalisations of tree
transformation with pattern matching, which is what OMeta is all about. While
most of it will be OMeta syntax, which I'll explain at length, OMetaJS is
written as a superset of JavaScript, and as such this article expects a fair
deal of familiarity with JavaScript concepts — JS will also be the compilation
target, so...

Section 7 provides a few TL;DR; paragraphs on the design and implementation of
programming languages, and Appendix A provides pointers to additional reading
and references to the things described throughout this article.


* 1. About general programming languages and DSLs

So, you know what programming languages are. You have probably heard of all
these weirdly named things, like Java, JavaScript, C, C++, C#, D, E, F#, LISP,
Scala, ... Well, perhaps you haven't heard about all of them, but you likely
know that they're things that let you talk to the computer, and in this sense,
they're not that much different from English or French.

Some people think programming languages are black magic. They're weaved by all
those long-bearded wizards that can bend the computer to do anything they
want. But that's not really true. Programming languages are just a way to
communicate ideas with the computer. The only requirement is that you be
familiar with the ideas you're encoding in your language.

Then there are Domain-Specific Languages. These are like regionalisms or
slangs. They are sub-sets of a particular language that are specific to a
particular domain. For example, you could write a language that only knew how
to talk to the computer about how to play music. Or a language that only knew
how to draw something on the screen.

People create new languages all the time, and there are all the sort of reasons
for that. It might be for making a particular thing run faster, or to make it
easier to express a particular idea (for example, parallel programs). But not
all languages are general languages, so people write Domain-Specific ones to
make it easier for non-programmers (or even to programmers) to express ideas
that are confined to a particular problem. DSLs are good because they make it
easier to reason about something in a particular domain, where a domain could
be physics, project automation, business logic, or anything.

This is also one of the reasons polyglot programmers are better at solving
problems than those who only speak one language. Polyglot programmers can
express ideas with more clarity and with less effort depending on what the
problem requires, by carefully choosing how they'll /talk/ about that problem
with the computer. Choosing the right language leads to a great reduction on
the overall complexity of a system, and the time necessary to build it.

And that, my dearest friends, is more or less why people write new
languages. Of course, there also all the sort of languages that are only
written out of boredom and academic curiosity. We're not going to deal with
languages [[http://tvtropes.org/pmwiki/pmwiki.php/Main/ForTheLULZ][FOR TEH LULZ]] here, however ;3


* 2. The semantics

Before getting our hands dirty with writing a compiler, we have to first decide
what we're going to build. As I said, languages are all about ideas. And ideas
in Programming Language Theory are just another word for *semantics*. For
example, the main ideas about JavaScript are /prototype object orientation with
single delegation/, /closures/, /first-class functions/, /applicative order/,
/strict evaluation/, etc. If you don't know what all of these are, don't worry,
it won't matter for now ;3

For the language we're going to build, we'll keep it as simple as
possible. It'll be a dynamically typed functional language with immutable
values for processing data[fn:1], modelled after a subset of the [[http://clojure.org/][Clojure]]
language. In other words, our language (let's call it Falsetto) will be able to
express the following ideas:

[fn:1]: While functional languages are good for this, concatenative or
        flow-based programming languages would likely fit the purpose better.


  - Functions as values (or First-Class Functions) ::
    Our language will treat functions as any other value (numbers, strings), so
    we can return it from other functions, take it as an argument, or store it
    in variables.

  - Immutable primitives (values) ::
    Our language will be able to talk about Numbers, Strings and Lists. All of
    these will be immutable — that is, once you create a List, you can't change
    the things in that List, but you can create a new List based on the
    original one.

  - Pattern matching ::
    Our language will choose different transformations to apply to the data
    depending on how the data looks. Pattern matching is a better way to branch
    like this for complex data structures.

  - Proper closures ::
    As a nice bonus from choosing to compile to JavaScript, we'll get proper
    closures for free (since I'll not go about on how to implement them).

  - Call by value/sharing ::
    Our language will evaluate the arguments to a function before applying the
    function, then pass the resulting values. Since everything is immutable, we
    don't need to pay the price to copy things to a new place in memory and
    just share the reference instead.

  - Multiple dispatching on structural typing ::
    Our language will use structural typing (or duck typing) to determine which
    branch of a function should be applied to a particular data structure. A
    function on the other hand will have to declare which kinds of data it
    supports. We call these kinds of functions *generics*, and they provide a
    nice and expressive way to write polymorphic code.

  - Automatic currying ::
    Our functions will be automatically [[http://en.wikipedia.org/wiki/Currying][curried]]. This means that if we have a
    function =f= that takes two arguments, and we apply that function one
    argument (say, =2=), we get a new function (=g=), which when applied to
    another argument will call =f= with the previous applied value and the new
    value. That is, =f(2)(3)= is the same as =f(2, 3)=.


The purposes of all these ideas is to make all the data transformations
easy to reason about and clearer. More than that, they are orthogonal concepts
that compose nicely and help making the language more expressive to the
particular problem we're designing it for: data processing.

Choosing orthogonal ideas that can be easily composed to provide an expressive
framework to talk to the computer about a particular problem is a good thing
(sometimes rather overlooked) when designing a new programming language.


* 3. The syntax

Since we're interested in making the most out of data processing in a
functional language, we're going to encode everything as a function. This means
that we'll have no operators, and as a side-effect of that we'll just use
[[http://en.wikipedia.org/wiki/Polish_notation][Prefix notation]] for simplicity. In other words, our language will be closer in
syntax to LISP, but without all the overloading of parenthesis. Rather, our
language will take inspiration on Dylan and Haskell.


** 3.1. Values

Ultimately our language is about values, and that's why we make them
immutable. Since we'll be dealing with values a lot, we need a nice way of
representing them. Here we'll use the same notation Clojure uses for them,
which is close to the JavaScript notation, with the only exception that strings
may span as many lines as they want:

#+BEGIN_SRC lua
  1, 12.35  -- Number
  "foo bar" -- String
  [1, 2, 3] -- List
#+END_SRC


** 3.2. Expressions and applications

Falsetto will be a expression language. In other words, we'll have no
statements, because statements only do side-effects and don't return a
value. And we care about values. A simple expression always ends up with a
semicolon, and expressions can be grouped into sequential blocks with braces
(={}=), in this case, the last expression in the brace is returned as the value
of the entire brace.

Function application is something we'll do a lot, so we encode application
as whitespace separated values. This leaves the usage of parenthesis in an
expression to be used exclusively for grouping expressions. For functions that
expect no parameters, we'll use a =!= suffix to call them (e.g.: =inc!=).

Assignments will be treated specially, both in syntax and meaning. This means
that you can't store an assignment, and you can't refer to it. Assignments are
scary and we'll leave them as alien thingies in this language.


** 3.3. Identifiers

Identifiers are the names we use to refer to values (and functions, which are
also values). For falsetto, we'll allow any combination of symbols to form a
name (with the exception of brackets, quotes, semicolons, commas and colons). A
name must start with anything that isn't a number, however, because numbers
already expect that, and we don't want the parser to be confused about whether
=12e= is a number or a name.

We'll use a convention similar to Dylan and Scheme when naming things:

 - Predicates :: 
   Predicates are functions that test something and return a boolean indicating
   whether the test passed or not. The name of these functions will end with
   a question mark (e.g.: =number?=). 

 - Constants ::
   These are things that are shared between several functions in a module. To
   easily distinguish them, we'll surround them in asterisks (e.g.:
   =*max-list-depth*=). Other languages tend to use uppercase letters, like
   =MAX_LIST_DEPTH=, but our identifiers are more expressive so we can make
   things a little more readable.

The identifiers =->= and => will be reserved because it's used by the function syntax,
and allowing that identifier would make things confusing. However, identifiers
like =string->number= are allowed.


** 3.6. Pattern matching

Last, but not least, Falsetto will have pattern matching. We'll use the same
notation we use for data structures to represent the patterns of values we
accept in a function.

A programmer will be able to combine patterns using three different set
operators: 

  - disjunction (=1 | 2=) ::
    will accept either values;

  - intersection (=[1, 2] & [ 2 ]=) ::
    will reduce the set of accepted values to one present in both; 

  - difference (=[1, 2] - [ 1 ]=) ::
    will accept everything that is in the former set but not the latter
    
Besides the operators, we'll use the wildcard character (=_=) to mean that we
accept any kind of value, and the range operator (=x ... y=) to define a set of
values accepted that are larger than x and smaller than y. A range of kind =[1,
2, ...]= will accept a list that starts with the numbers 1 and 2.

Specific parts of a pattern may be bound to a identifier by using the *binding*
(=:=) operator, such that the pattern =bs:[1, as:[ _ ], ...]= would create two
bindings, one referring to the whole list (=bs=) and the other referring to the
first sublist (=as=).

To talk about patterns, we'll have the special thing =match=, which will take a
list of patterns and the branches to execute if any of them matches:

#+BEGIN_SRC lua
  match n
  | 0   => 0;
  | 1   => 1;
  | n:_ => + (fib (- n 1)) (fib (- n 2));
#+END_SRC


** 3.5. Functions

Functions are our bread and butter. Functions are our tough guys. Functions
know their way 'round the town. Functions know how to deal with values and give
us back new values. Since functions will be used extensively, we need a concise
way of writing them:

#+BEGIN_SRC lua
  -- a simple function.
  add : (a, b) -> + a b;

  -- a function with lots of expressions. The last expression is always
  -- returned as the value of the function.
  foo : (a) -> { x : do-x-to a
               ; y : do-y!
               ; do-z-to x y
               }
#+END_SRC

For multiple dispatching, we'll allow the programmer to define the expected
types right in the parameter definition list. These use the same notation as
the pattern matching described previously.

#+BEGIN_SRC lua
  fib : (0)   -> 0;
  fib : (1)   -> 1;
  fib : (n:_) -> + (fib (- n 1)) (fib (- n 2));
#+END_SRC


** 3.6. Control flow

So far, we haven't mentioned any control flow syntax. If you're only familiar
with C-family languages (C, JavaScript, Java, etc.) you might be wondering how
the fuck you're supposed to write anything in this language at all. Well, if
that's what you were wondering, I'm proud to tell you that Falsetto will not
have any =if=, =cond=, =while=, =for=, or any other construct of the
sort. Instead, we'll only have pattern matching, multiple dispatching and
boolean functions.

What this means is that, instead of writing this:

#+BEGIN_SRC js
  if (foo == bar) { doX() }
  else            { doY() }
#+END_SRC

You'll be writing this:

#+BEGIN_SRC lua
  (foo == bar) { do-x! } { do-y! };
#+END_SRC

Or you can encode it as a function:

#+BEGIN_SRC lua
  when = (condition, consequent) -> condition consequent {};

  when (> 1 n) { do-x! };
#+END_SRC

A Boolean value is just a function, where =true= calls the first parameter, and
=false= calls the second parameter. If you're familiar with Smalltalk or Lambda
Calculus, those languages use this, and it gives an expressive framework the
programmer can use to write their own flow semantics — and flow is something we
really value in a language about data processing.

Loops can be easily replaced by recursion. Falsetto won't implement tail call
optimisation nor proper tail calls, but it's a relatively easy thing to do
(which I'll leave as an exercise to the reader ;3), other kinds of
transformations, like mapping or iterating over a list will be done using a
[[http://www.cs.nott.ac.uk/~gmh/fold.pdf][Fold]] (or =reduceRight=, as it's called in JavaScript).


* 4. Parsing with OMeta

So, now that we know how our language will more or less look like, and which
ideas we'll be able to talk about using it, it's about time we actually get our
hands dirty with the implementation. For this section, I'll introduce a little
bit of notation formalism, but it also happens to be the syntax for OMeta
programs. Rest assured, however, this will be simpler than you might expect it
to be :3


** 4.1. What is OMeta?

We discussed previously that OMeta is a thing that generalises the notion of
tree transformations, and as such can be used for writing the parser, optimiser
and compiler (or interpreter) for any programming language out there. It's a
really nice tool for prototyping programming languages either for playing
around, or to provide the basis for [[http://en.wikipedia.org/wiki/Self-hosting][Self-hosted compilers/interpreters]].

How OMeta does that? Well, OMeta is a language that provides a [[http://bford.info/packrat/][Packrat parser]]
in a parsing expression grammar. This means that we can parse any language in
OMeta in linear time[fn:2] (that is, the parsing time is only dependent on the
length of the input). Usually these kinds of parsers are recursive descent (we
start with the topmost rule, and recurse through the rules they refer to in
order to parse the input), and do not allow for left recursion. For example, a
regular PEG would not allow one to write this rule:

[fn:2]: Due to OMeta's optimisation for left-recursiveness. Direct and indirect
        recursive rules might be parsed in super-linear time, but the whole
        parser is still pretty much linear time.


#+BEGIN_SRC bnf
  -- An expression can be an addition of any expression with a number, or a
  -- simple number.
  -- `1` is a valid expression, as is `1 + 2 + 3`
  <expression> ::= <expression> "+" <number>
                 | <number>
#+END_SRC

OMeta implements a simple optimisation that allows these kinds of rules to be
expressed through the language without having to do any black magic (people
would usually rewrite the grammar to be right-recursive, which is not exactly
straight-forward). This makes OMeta much more approachable than regular parser
combinators or Parsing Expression Grammars (which are in turn much more
approachable than any other kind of parser).


** 4.2. The OMeta-JS language

OMeta-JS is a super-set of the JavaScript programming language that adds
a domain specific language to talk about tree transformations, using rules,
patterns, predicates and actions. These can be combined in several ways, and as
such form a rather expressive framework to talk about data transformations, be
it from =String -> Tree= or =Tree -> Tree=.





* 5. Optimisations as tree transformations

* 6. Compiling

* 7. Conclusion

* A. References and additional reading
