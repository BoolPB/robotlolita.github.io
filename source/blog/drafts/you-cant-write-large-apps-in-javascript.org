#+STARTUP: showall indent
#+OPTIONS: ^:{}
#+BEGIN_HTML
---
layout: post
title:  You can't write large apps in JavaScript
snip:   ...in fact, you really shouldn't, in any language.
---
#+END_HTML

Quite a while ago, at Lang.NEXT's expert panel on web and cloud
programming, Anders Hejlsberg raised an interesting point:

#+BEGIN_QUOTE
  *<Anders Hejlsberg>*
    I think it's fascinating too to see how much the programming
    languages' landscape has changed through the last few years and how it
    continues to change. And the language that was devised to be
    cross-platform, Java, is really no longer cross-platform, and there's
    a new cross-platform player in town called JavaScript, and the type
    system went out with the bath water.
    
    And now we can wonder about how we can do medium to large scale
    efficient development, so there's lots of new work invented there that
    we can all stop to ponder.

  *<Erik Meijer>*
    Are you implying you can't write big programs in JavaScript?

  *<Anders Hejlsberg>*
    No, I think you can. But I don't think you can maintain it.
#+END_QUOTE

Which was followed by Anders' experiences on refactoring a large
JavaScript code-base, Gilad's words on how that's one of the problems
Dart tries to solve, by giving people decent libraries and abstractions,
and Erik's point on JavaScript not being tied to HTML or such.

Although, I believe, Anders' point wasn't exactly that JavaScript is an
utterly unsuited language for any large application feature-wise, but
rather that there's a whole lot of other tools that aren't much used (or
existent) in the language that you see in the likes of Java or C#. So,
in this blog post we'll see how composing small applications solves
(most of) the maintainability problem posed by big apps, and provide
pointers on how to write and maintain such programs. Stick with me!


* The problem

As web-applications grow bigger and complex by the second, we have to
keep up with the pace. The web is getting a lot more interactive, and
single-page web apps are sprouting every which way. This means we can't
keep writing our front-end code the same way we used to do in the 90's —
for starters, no one really knew JavaScript back then.

There are well-defined patterns for languages considered to be /fit for
large-scale programs/, which people follow suit to make their program
more maintainable. One of the main players in this field is still the
Java language, and all its disgusting patterns. JavaScript can do
better, since it's a whole lot more featureful and expressive — although
it lacks on the number of maintaining tools and libraries, but we'll get
there, eventually.

If we were to define the root of the maintainability problems in
JavaScript, we could divide those in the following categories:


  - Lack of proper abstractions :: 
       truth be said, ECMAScript almost takes minimalism at face value. As such,
       there's no way in hell anyone could write any program in ECMAScript
       using only what's provided out of the box.

  - Lack of larger composition primitives :: 
       ECMAScript gives you really nice primitives for programming: first-class
       functions with proper closures, and prototypical object orientation, but
       nothing to separate groups of these in logical partitions in a sane
       way. No, global namespaces aren't sane for this, but first-class
       ones are still useful.

  - Tight coupling :: 
       Most ECMAScript programs today have way too many dependencies, such that
       any small change can have large consequences throughout the
       entire program.

  - Lack of tools :: 
       This is often aggravated by *tight coupling*. Refactoring
       is expensive when there's hardly much tooling to help
       you. Program verification poses a similar problem.



* The power of abstractions

Good abstractions are quintessential for writing maintainable programs. They
let us express ideas concisely, without having to deal with all the details
associated with such. This is particularly important because it reduces the
time necessary to convey a particular meaning through the code: /what function
X does, what object Y is used for, etc/.

The main primitives for abstraction in JavaScript are first-class functions and
prototypical object orientation. While functions abstract over processes,
objects let you logically group processes into behaviours and derive from those
behaviours for code reuse.

As an example, take the following way of rendering a list of Tweets on the
screen:

#+BEGIN_SRC js
  function render_tweets(tweets) {
    var i = 0
    var len = tweets.length

    for (; i < len; ++i) {
      var t = tweets[i]

      var tweet = document.createElement('div')
      tweet.className = 'tweet'
      tweet.appendChild(document.createTextNode(t.text))

      var reply = document.createElement('a')
      reply.className = 'tweet-reply'
      reply.appendChild(document.createTextNode('Reply to @' + t.user.screen_name))
      reply.setAttribute( 'href'
                        , 'http://twitter.com/?status=@' + t.user.screen_name
                          + '&in_reply_to_status_id='    + t.in_reply_to_status_id_str
                          + '&in_reply_to='              + t.user.screen_name)
      
      document.querySelector('#tweets').appendChild(tweet) }}
#+END_SRC

Pretend you're asked by one of your co-workers to take a quick look at the
above's function code and tell him, roughly, what its intended uses are and how
it achieves that. You wouldn't be able to do it, at least, not without
carefully reading the source code first.

Suppose he then goes to show you this piece of code instead:

#+BEGIN_SRC js
  function render_tweets(tweets) {
    var container = document.querySelector('#tweets')

    tweets.map(render_tweet)
          .forEach(function(rendered_tweet){ 
                     container.appendChild(rendered_tweet) })}
#+END_SRC

Can you tell what it does, roughly, at a glance? Sure you can. This snippet
provides a much *higher-level* view of the source code. Instead of telling you
how it goes about doing things, it tells you exactly *what* it does: Takes a
list of tweets, renders each one of them, then appends each one of the rendered
tweets to the =#tweets= container.

However, it doesn't tells you much about “What a =rendered_tweet= is?”. Let's
fix that:

#+BEGIN_SRC js
  function make_element(tag) {
    return document.createElement(tag) }


  function make_text(text) {
    return document.createTextNode(text) }


  function render_tweet(tweet) {
    var tweet = make_element('div')
    tweet.className = 'tweet'
    tweet.appendChild(make_text(tweet.text))
    tweet.appendChild(render_reply_link( tweet.user.screen_name
                                       , tweet.in_reply_to_status_id_str ))

    return tweet }
#+END_SRC

So, a =rendered_tweet= is an element containing the text of a tweet and a reply
link. Still, this doesn't give us “What a =reply_link= is”.

#+BEGIN_SRC js
  function render_reply_link(user, status_id) {
    var reply = make_element('a')
    reply.className = 'tweet-reply'
    reply.setAttribute('href', make_reply_url(user, status_id)
    reply.appendChild(make_text('Reply to @' + user)) }


  function make_reply_url(user, status_id) {
    return 'http://twitter.com?status=@'               + user
         +                   '&in_reply_to_status_id=' + status_id
         +                   '&in_reply_to='           + user }
#+END_SRC

As you see, each /process/ is carried over by a function. When a process
becomes too complex (conceptually), it's split over into sub-processes,
such that you have a main process to *coordinate* everything, and
several sub-processes that carry out the *details* of the
operation. That's what abstractions are for, and knowing it will save
your bacon, son.


As a rule of thumb, /processes/ should do just one thing — which doesn't
mean that they should have only one expression, but rather that the idea
the process conveys should be faithful to its name, both in what it
does, and in the level of abstraction it uses.


* Structuring applications



* Artefacts of compositionality

* Testing
