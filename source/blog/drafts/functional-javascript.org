#+STARTUP: showall indent
#+OPTIONS: ^:{}
#+BEGIN_HTML
---
layout: post
title:  Functional JavaScript
snip:   Bringing parens back to JS, without the parens.
---
#+END_HTML

Functional programming is becoming a hot topic these days. Programmers
are (re-)discovering functional idioms in their old languages, and new
languages often feature multiple paradigms, with support to functional
idioms to a certain extent — even Java is getting lambda expressions!

JavaScript is one of these multiple paradigm languages, taking its
functional side from [[http://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]], a minimal dialect of the [[http://en.wikipedia.org/wiki/Lisp_programming_language][Lisp]] family. It
is, however, at the same time, a language designed for monkey patching,
which means that side-effects are tied straight into the core of the
language.

This raises several questions on the validity of stating that JavaScript
allows for functional idioms. In this article we'll go through what
functional programming really is, how it applies to JavaScript and which
kind of new and interesting composition patterns it allows in the
language.


* Introduction

So, what's this “functional programming” business anyways?

Well, functional programming has a fuzzy meaning these days (just not as
fuzzy as /Object Oriented Programming/, I think). But in essence,
functional programming languages revolve around computing expressions,
rather than mutating some state through a series of statements.

The major requirement for a programming language to support functional
programming idioms is that functions *must be first-class[fn:1]*
citizens. That is, functions need to be treated as any other value in
the language, which means being able to at least pass them as arguments
to other functions, store them in variables and return them from other
functions.

Modern functional languages include several other features to improve
the language's expressiveness, and make it easier to reason about a
given program. Those include closures, higher-order functions,
referential transparency and lazy evaluation.
 
[fn:1]: *first-class* is not a well-defined term, actually. It depends
        mostly on how other kinds of primitive values are treated in the
        language. The rights of function objects should be at least the
        same as those. In JavaScript, in addition to the rights
        mentioned above, functions can also store properties, since
        that's something every object in the language can do.


** The basic theory

The idea of functional abstracions comes from Alonzo Church's
[[http://en.wikipedia.org/wiki/Lambda_calculus][lambda calculus]], which intended to use functions as the foundation of
mathematics. The lambda calculus semantics defines computations and
values as a series of lambda expressions. These expressions are
evaluated through a series of reductions that take an abstraction to the
value it represents.

Take the following mathematical expression: =2 + 3 * (5 / 2) - 1=. We
can compute the value of the expression by reducing it to a value:

#+begin_src text
  = 2 + 3 * (5 / 2) - 1
  = 2 + 3 * (2.5) - 1
  = 2 + 7.5 - 1
  = 9.5 - 1
  = 8.5
#+end_src

In lambda calculus, a similar series of reductions is used to evaluate a
lambda expression:

#+begin_src text
  calc = (λa → λb → λc → λd → a + b * (c / a) - d) 2
       = (λb → λc → λd → 2 + b * (c / 2) - d) 3
       = (λc → λd → 2 + 3 * (c / 2) - d) 5
       = (λd → 2 + 3 * (5 / 2) - d) 1
       = (2 + 3 * (5 / 2) - 1)
       = 2 + 3 * (2.5) - 1
       = 2 + 7.5 - 1
       = 9.5 - 1
       = 8.5
#+end_src

The biggest difference is that, instead of defining the numbers directly
in the expression, we abstract that into /lambda abstractions/. That is,
we have functions that take numbers as arguments for the computation,
and they return other lambda abstractions[fn:2].

When a lambda abstraction is applied to a number, we substitute all the
terms with the same name as the lambda abstraction parameter by that
number.

That is, =2= could be abstracted as =λx → x= (a lambda abstraction
taking =x=, and immediately yielding =x=)[fn:3], and then we could apply
numbers to get them back: =(λx → x) 2= would yield =2=.


[fn:2]: In /lambda calculus/ everything is actually a function (or
        lambda), even numbers are represented as functions with
        something known as [[http://en.wikipedia.org/wiki/Peano_axioms#The_axioms][Peano Numbers]].

[fn:3]: The lambda abstraction =λx → x= is also called *Identity* (or I,
        for short). And it's a core combinator in Lambda Calculus. The
        combinators are: =I: λx → x=, =K: λx → λy → x=, 
        =S: λx → λy → λz → x z (y z)=. You could express any computation
        using only those combinators.


** Why use functional programming?

Functional idioms provide an alternative method for composing programs,
which tends to lead themselves more easily to a good deal of modularity,
given the emphasis placed in purity, abstractions — usually in terms
of higher-order functions — and declarative definitions of the
computation being performed.

The declarative definitions are usually self-explanatory on what the
operation being executed is about — rather than how this operation
should be executed. This helps conveying the intent of such a piece of
code. On the other hand, it makes it a little more difficult to
understand the /how things get done/ part.

Such properties can, arguably, make the resulting application a great
deal shorter, less complex, and easier to inspect and reason about, for
the programmer has to keep less information in his head at any given
time.

On a more objective note, we could list unit testing, debugging and
concurrency as the three major (and proven) benefits of functional
programming. In particular, functional idioms have had a massive
adoption over the last few years to improve the concurrent capabilities
of imperative languages.

In a functional program, since functions don't depend on shared state,
the compiler can just parallelise everything and combine the results
afterwards, it doesn't need to follow a strict evaluation order. In
fact, this property leads to such a increase in the potential of static
analysis of a program that a well-developed compiler can do a whole lot
more of aggressive optimisations based on rewriting your program's order
or phasing out evaluating some expressions completely — [[http://www.haskell.org/haskellwiki/Haskell][Haskell]] does
just that.

It's also because of the premise of not depending on shared state that
unit testing and debugging are made a lot easier. For unit testing, you
only need to verify that your function yields valid results for the
given set of inputs its expected to receive. In fact, there are tools
that will randomly generate a set of potential inputs and feed them to
your function for testing, automatically (Haskell's [[http://www.cse.chalmers.se/~rjmh/QuickCheck/][QuickCheck]] is a good
example), which is referred to as /random property testing/.


* Functions

Functions are, basically, a means of abstracting computations, as
discussed previously in the section on the theory behind functional
programming. This means that if I have the expression =2 + 2=, I can
have a function that abstracts over that expression[fn:4]:

#+begin_src js
  2 + 2
  // => 4

  function two_plus_two() { return 2 + 2 }
  two_plus_two()
  // => 4
#+end_src

Functions are usually given a name (though not necessarily always), a list of
parameters for the computation they should perform and a list of statements
describing the process they perform.


#+BEGIN_SRC ditaa :file ../../media/assets/fp-fndef.png :cmdline -r :exports none
            Name      Parameters
              |           | 
           +--+-=+  +-----+--=--+ +---+
  function | add | (|left, right|)| { |
           +-----+  +-----------+ |   :
  +-------------------------------+   +--- Body
  |   return left + right             |
  |   +-------------------------------+
  | } |
  +---+
#+END_SRC

#+RESULTS:
[[file:../../media/assets/fp-fndef.png]]

[[blog:fp-fndef.png]]

A =return= statement allows a function to yield back the result of the
computation that was performed. Different from the mathematical concept of
functions, though, functions in JavaScript don't need to always return a
value. If a =return= statement is not present in the function, it's implicit
that the return value of such function is the special value =undefined=.

Functions that describe processes to be executed, rather than an expression to
be evaluated, can happily omit the =return= statement. Such functions usually
affect the state of the program outside of the function's realms (e.g.: by
changing some object's properties or a non-local variable's value), and are
described as having *side effects* or being *impure*. We'll dwell on the
subject shortly.

More formally, the common anatomy of a function definition can be described by
the following grammar rules:

#+BEGIN_SRC bnf
  <function-stmt> ::= "function" <function-name>¹ <arguments> <function-body>
  <function-name> ::= <identifier>
  <arguments>     ::= "(" (optional <argument-list>) ")"
  <argument-list> ::= <identifier> (many "," <identifier>)
  <function-body> ::= "{" (many <statement>) "}"

  # ¹: Optional for `FunctionExpression's. We discuss this in the next session.
#+END_SRC


[fn:4]: While this generic claim may still hold true for JavaScript,
        it's important to note that functions in the language don't
        respect Tennet's Correspondence Principle, as such you can't just
        wrap every expression in a function while preserving all of the
        properties of the expression before wrapping it.


** Definition

There are two ways for defining a function in ECMAScript, which depends mostly
on the context in which such definition happens. Both ways are equivalent,
however, in the sense that they both create a function object with the same
properties.

First, we have what the [[http://ecma-international.org/ecma-262/5.1/#sec-13][specs]] call a =FunctionDeclaration=, which happens at
the statement level. Since statements are things that yield no value, a
=FunctionDeclaration=, instead of returning a function object, binds that
object to the current scope, with the name the function was declared with.

This means that if we declare a function named =square= in this manner, we can
refer to it right away by that name:

#+BEGIN_SRC js
  function square(x) { return x * x }

  square(2)
  // => 4
#+END_SRC

An interesting property of =FunctionDeclarations= is that they are
*hoisted* [fn:5], that is, regardless of where you declare them in your
source code, they will be available anywhere in the scope. This allows
for interesting orderings of a program's source code, without being
bound by the declaration order:

#+BEGIN_SRC js
  square(2)
  // => 4

  function square(x) { return x * x }
#+END_SRC

The other way of creating a function object is by what the specs call a
=FunctionExpression=. The syntax is the same as a =FunctionDeclaration=, except
the function's name is optional. Rather than binding the resulting function
object to the current scope, a =FunctionExpression= works by making that
function object the result of the expression. This result can afterwards be
invoked, stored in a variable or passed as a parameter to another function.

It might sound a bit insane at first, but this is an extremely powerful
feature in the language. We can decide when we want to treat a function
as an object — a value we can manipulate, — or execute it to have a
computation performed.

If we were to write the previous =square= function as a
=FunctionExpression=, it wouldn't be much useful to just write the
function definition, we'd have to store it somewhere so we could use it
later on. For example, we could bind it to a variable:

#+BEGIN_SRC js
  var square_of = function(x){ return x * x }
#+END_SRC

Now, we have a variable =square_of= that holds a function which, when
called with a numeric parameter, computes the square of that
number:

#+BEGIN_SRC js
  square_of(3)
  // => 9
#+END_SRC

Note that when you want to execute a function you need to use the
additional parenthesis. Otherwise, the function is just treated as a
regular object — the same way =Strings= or =Numbers= are. The act of
executing a function is also referred to as =calling=, or more formally
=applying= a function to some arguments.

We could further store this /function object/ in another variable, in
this case, both variables would point to the same function object in
memory:

#+BEGIN_SRC js
  var sqr = square_of
  sqr(3)
  // => 9

  square_of(3)
  // => 9

  sqr === square_of
  // => true
#+END_SRC

Sometimes you don't need to store a function object in a variable, but
rather just want to evaluate the function's statements and expressions
for their side-effects — isolating variables into a new scope (as we'll
discuss more later on). In this case, the =FunctionExpression= offers a
short-hand for that. Such that, instead of binding a function object to
a variable, then applying the function stored in that variable, you just
declare and call the function directly:

#+BEGIN_SRC js
  // It means that this piece of code:
  var temporary_function = function() {
                             alert('Hello, world!') }

  temporary_function()

  // Does the same thing as this one:
  void function() {
         alert('Hello, world!') }()

  // That is, both forms will alert `Hello, world!' right away.
#+END_SRC

The usage of the =void= operator in this case is just a trick to force
the engine to interpret the function declaration as a
=FunctionExpression= [fn:6], otherwise, it would think we wanted a
=FunctionDeclaration=. As we said before, a =FunctionDeclaration= is a
statement, and as such yield no value, thus we can't perform any
operation on it right away.

This pattern of executing a =FunctionExpression= immediately, is often
times called by the community an *Immediately Invoked
FunctionExpression*, or /IIFE/, for short.

[fn:5]: Hoisting is considered by many a misfeature. I think it has its
        uses, though it can be obviously abused. One of the interesting
        properties it allows is a more natural ordering of a program's
        source code, or even a little of literate programming.

[fn:6]: Prefixing a =FunctionDeclaration= with the =void= operator is
        just one of the ways of forcing a =FunctionExpression=, and the
        one I think makes the most sense. The =void= operator semantics
        basically say: /“I want this expression to be evaluated by their
        side-effects, but I don't care about its return value.”/. You
        will probably find examples of people wrapping functions in
        parenthesis, =(function(){ })()=, or prefixing functions with an
        exclamation mark, =!function(){}()=. They all serve the same
        purpose.


** Parameters and arity

Functions can declare which values their computation depends on. These
are referred to as *formal parameters*. It's basically a list of things
your function needs to know in order to perform the computation.

In impure languages like JavaScript, though, a function might depend on
other things that are not passed directly to the function, like global
variables or an object's property.

By declaring a list of *formal parameters*, a function is able to
generalise a certain computation to work on a range of different
inputs. The =square= function we declared previously is one example of
this, should we not have parameters, we'd need to declare one different
function for every possible input!

In /lambda calculus/ a function abstraction can only declare one formal
parameter it depends on. In JavaScript, however, a function can declare
any number of formal parameters that it depends upon. The number of
formal parameters a function expects is called *arity*, which is exposed
in JavaScript through the =length= property of every function object:

#+BEGIN_SRC js
  function square(x) { return x * x }
  square.length
  // => 1

  function pow(base, exponent){ ... }
  pow.length
  // => 2
#+END_SRC

The parameters passed over to the function, on the other hand, are
called /actual parameters/. For example, if we were to compute the
=square= of =2=, =2= would be the *actual parameter*, while =x= would be
the formal one:

#+BEGIN_SRC js
  square(2)
  // => 4
#+END_SRC

Likewise, if we were to invoke the =pow= function with arguments =2= and
=3=, the list of actual parameters would be =2, 3=, whereas the list of
formal parameters would be =base, exponent=:

#+BEGIN_SRC js
  pow(2, 3)
  // => 8
#+END_SRC

In JavaScript, however, a function doesn't need to declare the list of
formal parameters it expects, and regardless of the number of formal
parameters declared for a function, a function may receive any number of
actual parameters. This particular feature of functions, where the arity
of a function doesn't need to match the number of actual parameters is
called *variadic arity*, or *variadic* for short.

This means, that all of the following are valid JavaScript:

#+BEGIN_SRC js
  square(1, 2, 3, 4, 5)
  // => 1                       // 1 is `x', the other parameters aren't bound

  pow(2, 3, 4, 5)
  // => 8                       // 2 is `base', `3' is exponent

  square()
  // => NaN                     // `x' is `undefined'
#+END_SRC

So, you won't get an error when the number of actual parameters doesn't
match the arity of the function, and you might be wondering how this is
useful. I mean, it does look like an error, so why wouldn't it be
treated as such? What happens with the additional parameters you've
passed over to the function anyways?

As it happens, regardless of the formal parameters declared for a
function, all actual parameters can be accessed through a /magical/
variable called =arguments=. The =arguments= variable, available for
every function, is a list of all the actual parameters a function
received.

We could take advantage of this particular property to write a
=summation= function that can take any number of parameters:

#+BEGIN_SRC js
  function to_array(sequence) {
    return Array.prototype.slice.call(sequence) }

  function sum() {
    return to_array(arguments).reduce( function(result, item) {
                                         return result + item }
                                     , 0 )} // initial result

  sum(1, 2, 3, 4)
  // => 10                       // ((((0 + 1) + 2) + 3) + 4)
#+END_SRC

At first glance, the =arguments= object looks too much like your regular
=Array=, however, while the =arguments= object provides you with a
=length= property, and all of the actual parameters can be accessed by a
numeric index. The =arguments= is a special kind of object which doesn't
have any relation with an =Array=, besides implementing a common
=sequence= interface (having a =length= property and elements accessed
through numeric indexes):

#+BEGIN_SRC js
  (function(){ return arguments instanceof Array })()
  // => false
#+END_SRC

None the less, you can convert an =arguments= object to an array by
invoking the Array's =slice= method on the =arguments= object, as shown
previously in the =to_array= function.

An interesting relationship between the formal parameters and the
=arguments= object is that, according to the specifications, they both
refer to the same value, such that if you modify a value in the
=arguments= object, the respective formal parameter will be affected as
well, and vice-versa.

#+BEGIN_SRC js
  (function(x, y) {
     arguments[0] = y
     return x + y })(2, 3)
  // => 6                       // 3 + 3


  ;(function(x, y) {
      x = y
      return arguments[0] + arguments[1] })(2, 3)
  // => 6                       // 3 + 3
#+END_SRC



** Application

Although we have briefly discussed function application throughout the
previous sections, there are still a few concepts worthy discussing in
more detail. Specially in the presence of /variadic/ functions.

So, /application/ is the act of invoking a particular function with a
given list of formal parameters. In /JavaScript/, however, there are two
different kinds of parameters you can pass to a function when applying
them: [[http://killdream.github.com/blog/2011/10/understanding-javascript-oop/index.html#sec-2][special parameters]] (or the =this= binding), which only make sense
for functions that act as methods; and the /formal parameters/, which we
have discussed in the previous section.

Since /this/ bindings don't play much of a role outside of Object
Orientation patterns, we won't discuss it here, however my [[http://killdream.github.com/blog/2011/10/understanding-javascript-oop/index.html#sec-2][previous
article on JavaScript's Object Orientation]] describes it at length.

Back to the functional world, there are two ways /formal parameters/ can
be applied to a function. And choosing between one or the other depends
on whether you know the number of arguments you'll be using in advance
or not.

When the arguments to apply are statically known, the way we've been
using up until now for invoking functions is the way to go:

#+BEGIN_SRC js
  function add(x, y) { return x + y }
  add(1, 2)
  // => 3
#+END_SRC

However, sometimes the arguments you're applying aren't readily stored
in variables, or the function's /arity/ is unknown. For these cases, you
have a /variadic application/ method for functions. This takes care of
applying a list of parameters of arbitrary length to some function:

#+BEGIN_SRC js
  add.apply(null, [1, 2])       // same as add(1, 2)
  // => 3
#+END_SRC



* Structure and scoping

Now that we know how to define and evaluate abstractions over
computations (aka functions), let's dive deeper and understand the
structure of a function and its declarations.

This section will guide you through the internal representations of a
function[fn:7], as well as scoping rules for its definitions. That is, how
does the JavaScript engine decide where a given definition (a parameter
or a variable) is valid, and how it resolves an identifier to its bound
value.

[fn:7]: We'll be using higher-level descriptions taken mostly
        from the specifications, since the actual representation will be
        platform-specific.


** Lexical scoping

There are basically two kinds of scoping in programming languages:
/dynamic scoping/ and /lexical scoping/. JavaScript, as most other
modern languages, uses the latter. Some languages use a combination of
the two, and most old languages uses the former.

In a /lexically scoped/ (or /statically scoped/) language, any given
identifier has its scope fixed at the time of the compilation to the
region it's been declared in the source code. Such regions may be
=blocks=, =functions=, =procedures= or some other kind of delimiter used
by the language. In JavaScript, only =functions= define new /scopes/ [fn:8],
and as such identifiers are only valid in the =function= they have been
declared.

#+BEGIN_SRC js
  function add(x, y, continuation) {
    continuation(x + y)
  }

  add(1, 2, function(result) {
    x // => ReferenceError, since `x' is not declared in this region.
  })
#+END_SRC

On the other hand, /dynamically scoped/ languages have the scope of an
identifier based on the run-time evaluation of a program's source
code. This means that it's the nesting of function calls that define
where and how long an identifier is valid. For example, if JavaScript
had dynamic scopes, the previous example would yield this:

#+BEGIN_SRC js
  function add(x, y, continuation) {
    continuation(x + y)
  }

  add(1, 2, function(result) {
    x // => 1, since we're still inside `add's run-time evaluation
  })
#+END_SRC

/Lexical scoping/ makes it easier to reason about a given piece of code,
since you can analyse the effects of a given identifier just by looking
at the source code alone, whereas /dynamic scoping/ requires one to know
the order in which functions are called in order to know such
effects. /Lexical scoping/ also allow nested function definitions, where
the inner functions can use values defined in the outer function.


[fn:8]: The exception to this rule is a =try/catch= block, where the
        =catch='d error identifier is actually scoped to the =catch=
        block. Also, the new version of ECMAScript introduces /block
        scoping/ through the [[https://developer.mozilla.org/en/JavaScript/Reference/Statements/let][=let=]] operator.


** Declarations and Hoisting

There are three ways a name ends up in the scope:

  - Variable declaration
  - Function declaration
  - Function parameter declaration

We went over /function declarations/ and /parameter declarations/
before, so we'll just cover /variable declarations/ here and how
hoisting affects all declarations within a scope.

Variables are introduced (*bound*) in a scope through the statement
=var=. When a variable is declared within a function scope, it is
taken to be /local/ to that scope. You can contrast this to variables
that are accessible from the current scope, but are declared on
enclosing scopes (/non-local/), and variables that are declared on the
top-level scope (/global/).

#+BEGIN_SRC js
  var foo = 1;          // global
  void function Parent() {
    var foo = 2;        // non-local
    void function Current() {
      var foo = 3;      // local
      console.log('local foo:', foo)
    }()
  }()

  // => 'local foo: 3'
#+END_SRC

It's important to note that JavaScript doesn't prevent assignments to
undeclared variables, instead, it acts as a new variable declaration on
the top-level scope. *Leaked* globals in this manner makes it more
difficult to reason about a code-base, since side-effects are not
immediately apparent.

#+BEGIN_SRC js
  void function() {
    foo = 1
  }()
  console.log(foo)  // => 1
#+END_SRC



Back to the declarations matter, as mentioned previously, all
declarations are hoisted within the scope they occur. This means that
regardless of where the declarations appear physically, they're executed
before any code in the scope, in 



** Locals vs Globals
** Environments
** Closures
* Patterns
** Recursion
** Higher-order functions
** Continuations
* Practical applications
** Currying and uncurrying
** Composition
** Memoisation
** Encapsulation
* Functional philosophy
** Referential transparency
* Wrapping it up
* References
